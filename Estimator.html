<!DOCTYPE html>
<html lang="en">

<head>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                console.log('Attempting to register service-worker.js'); // Added log
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered successfully:', registration);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            });
        } else {
            console.warn('Service workers are not supported in this browser.');
        }
    </script>
    <link rel="manifest" href="manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concrete Estimator</title>
    <style>
        /* The Modal (hidden by default) */
        #formula-generator-modal {
            display: none;
            /* Hidden by default */
            position: fixed;
            /* Stay in place */
            z-index: 1;
            /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
            overflow: auto;
            /* Enable scroll if needed */
            background-color: rgba(0, 0, 0, 0.4);
            /* Black w/ opacity */
        }

        /* Modal Content/Box */
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            /* 10% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            /* Could be 80% or a fixed size */
            max-width: 600px;
            /* Optional: maximum width */
        }

        /* The Close Button */
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        /* Bracket Row Styling (adjust as needed) */
        #modal-brackets .bracket-row {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
            align-items: center;
        }

        #modal-brackets .bracket-row input {
            width: 80px;
        }

        #modal-brackets .bracket-row select {
            width: 100px;
        }

        #modal-brackets .cost-per-sf-input {
            display: block;
        }

        #modal-brackets .fixed-cost-input {
            display: none;
        }

        /* Basic Styling */
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            font-size: 14px;
        }

        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            max-width: 900px;
            margin: auto;
        }

        .navigation button {
            padding: 10px 15px;
            margin-right: 10px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1em;
        }

        .navigation button:hover {
            background-color: #0056b3;
        }

        .navigation button.active {
            background-color: #004085;
            font-weight: bold;
        }

        button {
            font-size: 1em;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #e9e9e9;
            margin-right: 5px;
            margin-bottom: 5px;
            /* Spacing for buttons */
        }

        button:hover {
            background-color: #d4d4d4;
        }

        /* Smaller Up/Down buttons */
        button.move-button {
            padding: 2px 6px;
            font-size: 0.9em;
            line-height: 1;
            vertical-align: middle;
            margin-right: 3px;
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            padding: 8px;
            margin: 2px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1em;
            width: 100%;
        }

        /* Style for color input */
        input[type="color"] {
            padding: 2px;
            height: 36px;
            vertical-align: middle;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            width: 60px;
        }

        textarea {
            resize: vertical;
        }

        label {
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }

        .page-section {
            display: none;
            margin-top: 20px;
            border-top: 1px solid #ccc;
            padding-top: 20px;
        }

        .page-section.active {
            display: block;
        }

        h1,
        h2,
        h3 {
            color: #333;
        }

        hr {
            margin: 20px 0;
            border: 0;
            border-top: 1px solid #eee;
        }

        /* Tables */
        .settings-table,
        #proposal-options-table,
        #scope-templates-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            table-layout: fixed;
        }

        .settings-table th,
        .settings-table td,
        #proposal-options-table th,
        #proposal-options-table td,
        #scope-templates-table th,
        #scope-templates-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
            word-wrap: break-word;
            vertical-align: middle;
        }

        .settings-table th,
        #proposal-options-table th,
        #scope-templates-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        /* Cost Items Table Columns */
        .settings-table th:nth-child(1) {
            width: 20%;
        }

        /* Name */
        .settings-table th:nth-child(2) {
            width: 10%;
            text-align: center;
        }

        /* Type */
        .settings-table th:nth-child(3) {
            width: 10%;
            text-align: center;
        }

        /* Unit */
        .settings-table th:nth-child(4) {
            width: 15%;
        }

        /* Value (Cost/Formula) */
        .settings-table th:nth-child(5) {
            width: 30%;
        }

        /* Description */
        .settings-table th:nth-child(6) {
            width: 15%;
            text-align: center;
        }

        /* Action */
        .settings-table td:nth-child(2),
        .settings-table td:nth-child(3),
        .settings-table td:nth-child(6) {
            text-align: center;
            white-space: nowrap;
        }

        /* Center Type, Unit, Action + Nowrap Action */
        .settings-table select.item-pricing-type {
            max-width: 80px;
        }

        .settings-table input[type="number"].item-cost {
            width: 90%;
            max-width: 90px;
        }

        .settings-table input[type="text"].item-unit {
            width: 90%;
            max-width: 70px;
        }

        .settings-table input[type="text"].item-formula {
            width: 95%;
            font-size: 0.9em;
            box-sizing: border-box;
        }

        .settings-table textarea.item-description {
            width: 100%;
            min-height: 40px;
            font-size: 0.95em;
            box-sizing: border-box;
        }

        .settings-table .delete-button {
            padding: 2px 5px;
            font-size: 0.85em;
        }

        /* Smaller delete button */

        /* Proposal Options Table Columns */
        #proposal-options-table th:nth-child(1) {
            width: 25%;
            text-align: left;
        }

        /* Name */
        #proposal-options-table th:nth-child(2) {
            width: 35%;
            text-align: left;
        }

        /* Description */
        #proposal-options-table th:nth-child(3) {
            width: 12%;
            text-align: center;
        }

        /* Type */
        #proposal-options-table th:nth-child(4) {
            width: 18%;
            text-align: center;
        }

        /* Value */
        #proposal-options-table th:nth-child(5) {
            width: 10%;
            text-align: center;
        }

        /* Action */
        #proposal-options-table td:nth-child(1),
        #proposal-options-table td:nth-child(2) {
            text-align: left;
        }

        /* Align name/desc left */
        #proposal-options-table input[type="number"].option-value {
            width: 90%;
            max-width: 100px;
        }

        #proposal-options-table select.option-type {
            max-width: 100px;
        }

        #proposal-options-table textarea.option-description {
            width: 100%;
            min-height: 40px;
            font-size: 0.95em;
            box-sizing: border-box;
        }

        #proposal-options-table td:nth-child(5) {
            white-space: nowrap;
        }

        /* Keep action buttons together */


        /* Scope Templates Table */
        #scope-templates-table th:nth-child(1) {
            width: 25%;
        }

        /* Name */
        #scope-templates-table th:nth-child(2) {
            width: 60%;
        }

        /* Text */
        #scope-templates-table th:nth-child(3) {
            width: 15%;
        }

        /* Action */
        #scope-templates-table textarea.scope-text {
            width: 100%;
            min-height: 60px;
            font-size: 0.95em;
            box-sizing: border-box;
        }

        /* Buttons & Feedback */
        .settings-actions {
            margin-top: 20px;
            display: flex;
            align-items: center;
        }

        .save-button {
            background-color: #28a745;
            color: white;
            border: none;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }

        .save-button:hover {
            background-color: #218838;
        }

        .save-button.unsaved-changes {
            background-color: #ffc107;
            color: #333;
            border: 1px solid #e0a800;
            box-shadow: 0 0 5px rgba(255, 193, 7, 0.5);
        }

        .save-button.unsaved-changes::after {
            content: " *";
            font-weight: bold;
        }

        .save-button.unsaved-changes:hover {
            background-color: #e0a800;
        }

        .feedback-span {
            margin-left: 15px;
            font-weight: bold;
            color: green;
            display: inline-block;
            vertical-align: middle;
        }

        .delete-button {
            background-color: #dc3545;
            color: white;
            border: none;
            font-size: 0.9em;
            padding: 5px 10px;
        }

        .delete-button:hover {
            background-color: #c82333;
        }

        .add-item-button {
            background-color: #17a2b8;
            color: white;
            border: none;
            margin-top: 15px;
        }

        .add-item-button:hover {
            background-color: #138496;
        }

        .import-export-button {
            background-color: #6c757d;
            color: white;
            border: none;
        }

        .import-export-button:hover {
            background-color: #5a6268;
        }

        /* Dashboard Specifics */
        .markup-section {
            margin-bottom: 20px;
            max-width: 250px;
        }

        .dashboard-item-container {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px dashed #eee;
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
        }

        .dashboard-item-container:last-child {
            border-bottom: none;
        }

        .dashboard-item-label {
            width: 220px;
            margin-right: 10px;
            font-weight: bold;
            padding-top: 8px;
            box-sizing: border-box;
        }

        .dashboard-item-input {
            display: flex;
            align-items: center;
            /* Align input and line total */
        }

        .dashboard-item-input input[type="number"] {
            width: 120px;
            margin-right: 10px;
        }

        /* Live Cost Display Style */
        .dashboard-line-total {
            margin-left: 10px;
            padding-top: 8px;
            /* Align vertically with input */
            font-size: 0.95em;
            font-weight: bold;
            min-width: 90px;
            /* Ensure space for currency */
            display: inline-block;
            text-align: right;
            /* Align currency right */
            color: #333;
        }

        .dashboard-item-desc {
            flex-grow: 1;
            font-size: 0.9em;
            color: #555;
            padding-top: 10px;
            font-style: italic;
            min-width: 200px;
            margin-left: 10px;
            /* Space after input+cost */
        }

        .total-sqft-container {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ccc;
            display: flex;
            align-items: center;
        }

        .total-sqft-container label {
            width: 220px;
            margin-right: 10px;
            margin-bottom: 0;
            font-size: 1.1em;
        }

        .total-sqft-container input {
            width: 120px;
            font-weight: bold;
        }

        .running-totals {
            margin-top: 25px;
            padding: 15px;
            background-color: #eef;
            border: 1px solid #cce;
            border-radius: 5px;
            max-width: 350px;
        }

        .running-totals h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #336;
        }

        .running-totals div {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .running-totals .label {
            font-weight: bold;
            color: #444;
            margin-right: 10px;
        }

        .running-totals .value {
            font-weight: bold;
            color: #000;
        }

        .running-totals .grand-total .value {
            font-size: 1.2em;
            color: #0056b3;
        }

        .dashboard-info-section {
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid #ccc;
        }

        .dashboard-info-section .info-item {
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
        }

        .dashboard-info-section label {
            width: 220px;
            margin-right: 10px;
            margin-bottom: 0;
            padding-top: 8px;
            flex-shrink: 0;
        }

        .dashboard-info-section input[type="text"],
        .dashboard-info-section textarea,
        .dashboard-info-section select {
            flex-grow: 1;
            max-width: 600px;
        }

        /* Apply max-width to select too */
        .dashboard-info-section textarea {
            min-height: 100px;
            resize: vertical;
        }

        .dashboard-option-item {
            /* Container for the whole option row on dashboard */
            display: flex;
            align-items: center;
            /* Align vertically */
            flex-wrap: nowrap;
            /* Prevent wrapping */
            margin-bottom: 8px;
        }

        .dashboard-option-item>div {
            /* Style direct children (containers) */
            margin-right: 15px;
            /* Space between sections */
            display: flex;
            align-items: center;
        }

        .dashboard-option-item>div:last-child {
            margin-right: 0;
        }

        /* No space after last item */
        .dashboard-option-item .label-container {
            /* Container for checkbox + name */
            width: 220px;
            flex-shrink: 0;
        }

        /* Reset some default label styles within this container */
        .dashboard-option-item label {
            font-weight: normal !important;
            cursor: pointer;
            margin-bottom: 0 !important;
            padding-top: 0 !important;
            display: inline !important;
            width: auto !important;
            margin-left: 4px;
        }

        .dashboard-option-item .option-toggle-checkbox {
            width: auto;
            margin-right: 8px;
            transform: scale(1.1);
        }

        .dashboard-option-item .value-container {
            /* Container for value input + type indicator */
            max-width: 160px;
        }

        .dashboard-option-item .option-dashboard-value {
            width: 100px !important;
        }

        .dashboard-option-item .value-type-indicator {
            font-size: 0.9em;
            margin-left: 2px;
        }

        .dashboard-option-item .show-on-quote-container,
        .dashboard-option-item .optional-addition-container {
            padding-left: 15px;
            border-left: 1px dotted #ccc;
            flex-shrink: 0;
        }

        /* Style checkboxes within the option item row */
        .dashboard-option-item .option-dashboard-show-toggle,
        .dashboard-option-item .option-dashboard-is-optional {
            transform: scale(1.1);
            cursor: pointer;
            width: auto;
            /* Override default input width */
        }

        /* PDF Actions Area - Using Flexbox for better button layout */
        .pdf-actions {
            margin-top: 30px;
            /* Increased spacing */
            padding-top: 20px;
            border-top: 1px solid #ccc;
            display: flex;
            /* Use Flexbox */
            flex-wrap: wrap;
            /* Allow buttons to wrap */
            gap: 10px;
            /* Space between buttons */
            align-items: center;
            /* Align items vertically */
        }

        /* Styling for specific PDF buttons */
        .pdf-actions button {
            /* Base style for all PDF buttons */
            padding: 8px 12px;
            font-size: 0.95em;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin: 0;
            /* Reset margin as gap is used */
        }

        .pdf-actions button:hover {
            filter: brightness(90%);
        }

        /* Specific Colors for PDF Buttons */
        #btn-generate-proposal-pdf {
            background-color: #007bff;
        }

        /* Blue */
        #btn-generate-field-quote-pdf {
            background-color: #17a2b8;
        }

        /* Teal */
        #btn-generate-letterhead-pdf {
            background-color: #28a745;
        }

        /* Green */
        #btn-generate-internal-pdf {
            background-color: #6c757d;
        }

        /* Grey */
        #btn-generate-subcontractor-pdf {
            background-color: #ffc107;
            color: #333;
        }

        /* Yellow */
        #btn-generate-subcontractor-pdf:hover {
            background-color: #e0a800;
        }

        .pdf-actions .feedback-span {
            margin-left: 5px;
            /* Reduced margin */
            width: 100%;
            /* Take full width on wrap */
            margin-top: 5px;
            /* Add space when wrapped */
            font-size: 0.9em;
            min-height: 1.2em;
            /* Reserve space */
            display: none;
            /* Hide initially, showFeedback will manage display */
        }


        /* Dashboard Scope Template Select */
        #scope-template-select {
            margin-bottom: 5px;
            max-width: 400px;
        }

        /* PDF Settings Specifics */
        #pdf-settings-section .setting-item {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }

        /* Allow wrapping */
        #pdf-settings-section label {
            display: block;
            margin-bottom: 5px;
            width: 220px;
            /* Align labels */
            flex-shrink: 0;
            padding-right: 10px;
        }

        #pdf-settings-section input[type="text"],
        #pdf-settings-section textarea,
        #pdf-settings-section input[type="file"]

        /* Style file input consistently */
            {
            width: 100%;
            max-width: 500px;
        }

        /* Adjust width for color input */
        #pdf-settings-section input[type="color"] {
            max-width: 60px;
            width: auto;
            margin-right: 10px;
        }

        #pdf-settings-section textarea {
            min-height: 80px;
            resize: vertical;
        }

        #logo-preview {
            max-height: 40px;
            max-width: 150px;
            display: none;
            margin-top: 3px;
            border: 1px solid #eee;
            padding: 2px;
            vertical-align: middle;
        }

        #logo-status {
            font-size: 0.8em;
            color: #888;
            margin-left: 5px;
        }

        /* Container for logo related elements */
        .logo-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-grow: 1;
            max-width: 500px;
        }

        /* Backup/Restore Area */
        .backup-restore-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #007bff;
        }

        .backup-restore-section h3 {
            color: #0056b3;
            margin-bottom: 15px;
        }

        .backup-restore-section button {
            margin-right: 10px;
        }

        .backup-restore-section p {
            font-size: 0.9em;
            color: #555;
            margin-top: 5px;
            margin-bottom: 15px;
        }

        /* Input Validation Style */
        input.invalid,
        textarea.invalid,
        select.invalid {
            border-color: red !important;
            background-color: #fff0f0;
        }

        .validation-error-message {
            color: red;
            font-size: 0.9em;
            margin-left: 10px;
            display: none;
            /* Hide initially */
        }

        /* General Error Display */
        #initialization-error-display {
            color: red;
            border: 2px solid red;
            background-color: #fff0f0;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
            display: none;
            /* Hidden by default */
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="initialization-error-display"></div>
        <h1>Concrete Estimator</h1>

        <div id="profile-management-controls"
            style="margin-bottom: 20px; padding: 15px; border: 1px solid #007bff; border-radius: 5px; background-color: #f0f8ff;">
            <h3 style="margin-top: 0; margin-bottom: 10px; color: #0056b3;">Manage Profiles</h3>
            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 10px;">
                <div>
                    <label for="profile-select" style="margin-right: 5px; font-weight: bold;">Active Profile:</label>
                    <select id="profile-select" style="padding: 6px; border-radius: 4px; min-width: 180px;">
                        <option value="">-- No Profile Selected --</option>
                    </select>
                </div>

                <div style="display: flex; align-items: center; gap: 5px;">
                    <input type="text" id="profile-new-name" placeholder="Enter profile name"
                        style="padding: 6px; border-radius: 4px; width: 200px;">
                    <button id="btn-create-profile"
                        title="Create a new profile using the name above (clones active profile, or uses defaults if none active).">Create
                        Profile</button>
                </div>
            </div>
            <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px;">
                <button id="btn-rename-profile" title="Rename the currently selected profile.">Rename Selected
                    Profile</button>
                <button id="btn-delete-profile" class="delete-button"
                    title="Delete the currently selected profile.">Delete
                    Selected Profile</button>
            </div>
            <span id="profile-feedback" class="feedback-span"
                style="display: block; margin-top: 10px; min-height: 1.2em;"></span>
        </div>

        <div class="navigation">
            <button id="btn-dashboard" class="active">Dashboard</button>
            <button id="btn-cost-items">Cost Items</button>
            <button id="btn-pdf-settings">PDF Settings</button>
            <button id="btn-proposal-options">Proposal Options</button>
            <button id="btn-scope-templates">Scope Templates</button>
        </div>

        <div id="dashboard-section" class="page-section active">
            <h2>Dashboard</h2>
            <p>Enter job details, dimensions, quantities, scope, and proposal options below.</p>

            <div class="dashboard-info-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3>Job & Customer Info</h3>
                    <button id="btn-clear-job-info" class="delete-button"
                        style="font-size: 0.9em; padding: 4px 8px;">Clear
                        Job
                        Info</button>
                </div>
                <div class="info-item"> <label for="client-name">Client Name:</label> <input type="text"
                        id="client-name" placeholder="Enter client name"> </div>
                <div class="info-item"> <label for="project-info">Project Name / Address:</label> <input type="text"
                        id="project-info" placeholder="e.g., Driveway Replacement at 123 Oak St"> </div>
                <div class="info-item">
                    <label for="scope-template-select">Scope of Work (Select Template or Edit):</label>
                    <div>
                        <select id="scope-template-select">
                            <option value="">-- Select a Template --</option>
                        </select>
                        <textarea id="scope-of-work"
                            placeholder="Select a template above or describe the work to be performed..."></textarea>
                        <span class="validation-error-message" id="scope-of-work-validation-error"></span>
                    </div>
                </div>
            </div>

            <div class="dashboard-info-section">
                <h3>Dimensions & Calculators</h3>
                <div class="info-item">
                    <label for="job-area">Area (sq ft):</label>
                    <input type="number" id="job-area" min="0" step="any" placeholder="Enter sq ft"
                        style="width: 120px;">
                </div>
                <div class="info-item">
                    <label for="job-thickness">Thickness (inches):</label>
                    <input type="number" id="job-thickness" min="0" step="any" placeholder="Enter inches"
                        style="width: 120px;">
                </div>
                <div class="info-item"
                    style="background-color: #f8f9fa; padding: 8px; border-radius: 4px; margin-left: 230px; max-width: 350px;">
                    <span style="font-weight:bold; margin-right: 5px;">Calculated Concrete Needed:</span>
                    <span id="calculated-concrete-volume">~0.00 cu yd</span>
                    <small style="display: block; color: #666;">(Based on Area, Thickness, and 10% waste. Enter actual
                        order
                        quantity below.)</small>
                </div>
            </div>

            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3>Material & Labor Quantities</h3>
                <button id="btn-clear-quantities" class="delete-button"
                    style="font-size: 0.9em; padding: 4px 8px;">Clear
                    All
                    Quantities</button>
            </div>
            <div id="dashboard-items">
            </div>

            <div class="dashboard-info-section">
                <h3 style="margin-bottom: 10px;">Temporary Job-Specific Items <small
                        style="font-size: 0.8em; color: #666;">(Not saved to profile)</small></h3>
                <div id="dashboard-temp-items">
                    <p><i>No temporary items added.</i></p>
                </div>
                <button id="btn-add-temp-item" class="add-item-button" style="margin-top: 10px;">+ Add Temporary
                    Item</button>
            </div>

            <div class="dashboard-info-section">
                <h3>Proposal Options / Adjustments</h3>
                <div id="dashboard-options">
                    <p><i>No proposal options defined in settings.</i></p>
                </div>
            </div>

            <div class="dashboard-info-section">
                <h3 style="margin-bottom: 10px;">Temporary Job-Specific Options / Adjustments <small
                        style="font-size: 0.8em; color: #666;">(Not saved to profile)</small></h3>
                <div id="dashboard-temp-options">
                    <p><i>No temporary options added.</i></p>
                </div>
                <button id="btn-add-temp-option" class="add-item-button" style="margin-top: 10px;">+ Add Temporary
                    Adjustment</button>
            </div>
            <div class="dashboard-info-section">
                <h3>Notes / Scratchpad (Internal Use Only)</h3>
                <textarea id="dashboard-scratchpad" rows="4"
                    placeholder="Temporary notes for this estimate (shown on Internal PDF, not saved or printed otherwise)..."></textarea>
            </div>

            <div class="running-totals">
                <h3>Live Estimate Summary</h3>
                <div> <span class="label">Subtotal (Materials/Labor):</span> <span class="value"
                        id="running-subtotal">$0.00</span> </div>
                <div> <span class="label">Markup (<span id="running-markup-percent">0</span>%):</span> <span
                        class="value" id="running-markup-amount">$0.00</span> </div>
                <div> <span class="label">Total Before Adjustments:</span> <span class="value"
                        id="running-total-before-options">$0.00</span> </div>
                <hr style="border-color: #cce; margin: 5px 0;">
                <div> <span class="label">Adjustments:</span> <span class="value"
                        id="running-options-adjustment">$0.00</span>
                </div>
                <hr style="border-color: #cce; margin: 5px 0;">
                <div class="grand-total"> <span class="label">Final Proposal Total:</span> <span class="value"
                        id="running-grand-total">$0.00</span> </div>
                <hr style="border-color: #cce; margin: 10px 0;">
                <div> <span class="label">Franchise Fee (8%):</span> <span class="value"
                        id="running-franchise-fee">$0.00</span>
                </div>
                <div> <span class="label">Profit After Fee:</span> <span class="value"
                        id="running-profit-after-fee">$0.00</span> </div>
                <div> <span class="label">Price Per Sq Ft:</span> <span class="value"
                        id="running-price-per-sqft">$0.00</span>
                </div>
            </div>
            <div id="dashboard-optional-additions"
                style="margin-top: 15px; padding-top: 15px; border-top: 1px dashed #ccc;">
                <h3 style="margin-top: 0; margin-bottom: 10px; color: #336;">Selected Optional Additions (Not in Total
                    Above)
                </h3>
                <div id="dashboard-optional-items-list">
                    <p><i>None selected.</i></p>
                </div>
            </div>
            <div class="pdf-actions">
                <button id="btn-generate-proposal-pdf"
                    title="Generate the full customer proposal PDF including header and footer.">Full Proposal
                    PDF</button>
                <button id="btn-generate-field-quote-pdf"
                    title="Generate only the job details (scope, totals) formatted to print on pre-printed letterhead.">Field
                    Quote PDF</button>
                <button id="btn-generate-letterhead-pdf"
                    title="Generate only the header and footer (logo, company info, terms) for pre-printing.">Letterhead
                    PDF</button>
                <button id="btn-generate-internal-pdf"
                    title="Generate a detailed internal estimate including all costs, markup, profit metrics, and scratchpad notes.">Internal
                    PDF</button>
                <button id="btn-generate-subcontractor-pdf"
                    title="Generate a PDF for subcontractors showing scope and base costs (no markup or final price).">Subcontractor
                    PDF</button>
                <span id="proposal-pdf-feedback" class="feedback-span"></span>
                <span id="field-quote-pdf-feedback" class="feedback-span"></span>
                <span id="letterhead-pdf-feedback" class="feedback-span"></span>
                <span id="internal-pdf-feedback" class="feedback-span"></span>
                <span id="subcontractor-pdf-feedback" class="feedback-span"></span>
            </div>
        </div>

        <div id="cost-items-section" class="page-section">
            <h2>Cost Item Settings</h2>
            <p>Configure base costs for materials, labor, and equipment. Use 'Fixed' for cost/unit or 'Formula' for
                calculated
                pricing. Use Up/Down arrows to reorder.</p>
            <div class="markup-section">
                <label for="markup">Default Markup Percentage:</label>
                <input type="number" id="markup" name="markup" min="0" step="0.1" value="40"> %
                <span class="validation-error-message" id="markup-validation-error"></span>
            </div>
            <hr>
            <h3>Cost Items</h3>
            <p>Edit the name, type, unit, value (cost or formula), and description. Formulas can use 'quantity',
                'jobArea',
                'jobThickness'.</p>
            <table class="settings-table" id="settings-table">
                <thead>
                    <tr>
                        <th>Item Name</th>
                        <th>Type</th>
                        <th>Unit</th>
                        <th>Value (Cost/Formula)</th>
                        <th>Description</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="settings-items-body"></tbody>
            </table>
            <button id="btn-add-item" class="add-item-button">+ Add New Item</button>
            <div class="settings-actions">
                <button id="btn-save-cost-items" class="save-button">Save Cost Items & Markup</button>
                <span id="cost-items-feedback" class="feedback-span"></span>
            </div>
            <div class="backup-restore-section">
                <h3>Settings Backup & Restore</h3>
                <p>Export the settings of the currently active profile to a JSON file, or import a profile from a file.
                </p>
                <button id="btn-export-settings" class="import-export-button">Export Active Profile</button>
                <button id="btn-import-settings" class="import-export-button">Import Profile from File</button>
                <input type="file" id="import-file-input" accept=".json" style="display: none;">
                <span id="backup-restore-feedback" class="feedback-span"></span>
            </div>
        </div>

        <div id="pdf-settings-section" class="page-section">
            <h2>PDF Output Settings</h2>
            <p>Configure company info and terms appearing on PDFs.</p>
            <div class="setting-item">
                <label for="pdf-logo-file">Company Logo Image File:</label>
                <div class="logo-controls">
                    <input type="file" id="pdf-logo-file" accept="image/png, image/jpeg">
                    <span style="font-size:0.85em; color: #666;">Preview:</span>
                    <img id="logo-preview" src="" alt="Logo Preview">
                    <span id="logo-status"></span>
                </div>
                <p style="font-size:0.85em; color: #666; margin-top: 4px; width: 100%; padding-left: 230px;">Select logo
                    (PNG/JPG, max 2MB). Stored locally.</p>
            </div>
            <div class="setting-item">
                <label for="pdf-company-website">Company Website URL:</label>
                <input type="text" id="pdf-company-website" placeholder="https://www.yourwebsite.com">
            </div>
            <div class="setting-item"> <label for="pdf-company-name">Company Name:</label> <input type="text"
                    id="pdf-company-name" placeholder="Your Company LLC"> </div>
            <div class="setting-item"> <label for="pdf-company-address">Company Address:</label> <textarea
                    id="pdf-company-address" placeholder="123 Main St&#10;Anytown, ST 12345"></textarea> </div>
            <div class="setting-item"> <label for="pdf-company-contact">Company Contact (Phone/Email):</label> <input
                    type="text" id="pdf-company-contact" placeholder="555-123-4567 | info@yourcompany.com"> </div>
            <div class="setting-item">
                <label for="pdf-proposal-line-color">Proposal Line Color:</label>
                <input type="color" id="pdf-proposal-line-color" value="#cccccc"> <span
                    style="font-size:0.85em; color: #666; margin-left: 5px;">Color for decorative lines on full proposal
                    PDF.</span>
            </div>
            <div class="setting-item"> <label for="pdf-default-notes">Default Notes/Terms (on Proposal):</label>
                <textarea id="pdf-default-notes" placeholder="Enter standard terms, conditions..."></textarea>
            </div>
            <div class="settings-actions">
                <button id="btn-save-pdf-settings" class="save-button">Save PDF Settings</button>
                <span id="pdf-settings-feedback" class="feedback-span"></span>
            </div>
            <div class="backup-restore-section">
                <h3>Settings Backup & Restore</h3>
                <p>Export the settings of the currently active profile to a JSON file, or import a profile from a file.
                </p>
                <button id="btn-export-settings-pdf" class="import-export-button">Export Active Profile</button> <button
                    id="btn-import-settings-pdf" class="import-export-button">Import Profile from File</button> <input
                    type="file" id="import-file-input-pdf" accept=".json" style="display: none;"> <span
                    id="backup-restore-feedback-pdf" class="feedback-span"></span>
            </div>
        </div>

        <div id="proposal-options-section" class="page-section">
            <h2>Proposal Options Settings</h2>
            <p>Define reusable options (discounts, upgrades, add-ons) that can be toggled on the Dashboard. Use Up/Down
                arrows
                to reorder.</p>
            <table id="proposal-options-table">
                <thead>
                    <tr>
                        <th>Option Name</th>
                        <th>Description</th>
                        <th>Type</th>
                        <th>Default Value (+/-)</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="proposal-options-body"></tbody>
            </table>
            <button id="btn-add-option" class="add-item-button">+ Add New Option</button>
            <div class="settings-actions">
                <button id="btn-save-options" class="save-button">Save Proposal Options</button>
                <span id="options-feedback" class="feedback-span"></span>
            </div>
            <div class="backup-restore-section">
                <h3>Settings Backup & Restore</h3>
                <p>Export the settings of the currently active profile to a JSON file, or import a profile from a file.
                </p>
                <button id="btn-export-settings-options" class="import-export-button">Export Active Profile</button>
                <button id="btn-import-settings-options" class="import-export-button">Import Profile from File</button>
                <input type="file" id="import-file-input-options" accept=".json" style="display: none;"> <span
                    id="backup-restore-feedback-options" class="feedback-span"></span>
            </div>
        </div>

        <div id="formula-generator-modal"
            style="display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div class="modal-content"
                style="background-color: #fefefe; margin: 10% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px;">
                <span class="close"
                    style="color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer;">&times;</span>
                <h2>Formula Generator</h2>

                <div>
                    <label for="modal-minTotalCost">Minimum Total Cost:</label>
                    <input type="number" id="modal-minTotalCost" value="1500">
                    <label for="modal-flatCost">Flat Cost:</label>
                    <input type="number" id="modal-flatCost" value="0">
                </div>

                <div id="modal-brackets">
                    <h2>Square Footage Brackets</h2>
                    <div class="bracket-row">
                        <input type="number" class="min-bracket-sf" placeholder="Min SF" value="1">
                        <input type="number" class="max-bracket-sf" placeholder="Max SF" value="250">
                        <select class="cost-type">
                            <option value="costPerSf">Cost/SF</option>
                            <option value="fixedCost">Fixed Cost</option>
                        </select>
                        <input type="number" class="cost-per-sf-input" placeholder="Cost/SF" value="10">
                        <input type="number" class="fixed-cost-input" placeholder="Fixed Cost" style="display: none;">
                        <button class="remove-bracket">Remove</button>
                    </div>
                    <div class="bracket-row">
                        <input type="number" class="min-bracket-sf" placeholder="Min SF" value="251">
                        <input type="number" class="max-bracket-sf" placeholder="Max SF" value="350">
                        <select class="cost-type">
                            <option value="costPerSf">Cost/SF</option>
                            <option value="fixedCost">Fixed Cost</option>
                        </select>
                        <input type="number" class="cost-per-sf-input" placeholder="Cost/SF" value="9.85">
                        <input type="number" class="fixed-cost-input" placeholder="Fixed Cost" style="display: none;">
                        <button class="remove-bracket">Remove</button>
                    </div>
                    <div class="bracket-row">
                        <input type="number" class="min-bracket-sf" placeholder="Min SF" value="351">
                        <input type="number" class="max-bracket-sf" placeholder="Max SF" value="499">
                        <select class="cost-type">
                            <option value="costPerSf">Cost/SF</option>
                            <option value="fixedCost">Fixed Cost</option>
                        </select>
                        <input type="number" class="cost-per-sf-input" placeholder="Cost/SF" value="9.65">
                        <input type="number" class="fixed-cost-input" placeholder="Fixed Cost" style="display: none;">
                        <button class="remove-bracket">Remove</button>
                    </div>
                    <div class="bracket-row">
                        <input type="number" class="min-bracket-sf" placeholder="Min SF" value="500">
                        <input type="number" class="max-bracket-sf" placeholder="Max SF" value="650">
                        <select class="cost-type">
                            <option value="costPerSf">Cost/SF</option>
                            <option value="fixedCost">Fixed Cost</option>
                        </select>
                        <input type="number" class="cost-per-sf-input" placeholder="Cost/SF" value="9.55">
                        <input type="number" class="fixed-cost-input" placeholder="Fixed Cost" style="display: none;">
                        <button class="remove-bracket">Remove</button>
                    </div>
                    <div class="bracket-row">
                        <input type="number" class="min-bracket-sf" placeholder="Min SF" value="651">
                        <input type="number" class="max-bracket-sf" placeholder="Max SF" value="800">
                        <select class="cost-type">
                            <option value="costPerSf">Cost/SF</option>
                            <option value="fixedCost">Fixed Cost</option>
                        </select>
                        <input type="number" class="cost-per-sf-input" placeholder="Cost/SF" value="9.45">
                        <input type="number" class="fixed-cost-input" placeholder="Fixed Cost" style="display: none;">
                        <button class="remove-bracket">Remove</button>
                    </div>
                    <div class="bracket-row">
                        <input type="number" class="min-bracket-sf" placeholder="Min SF" value="801">
                        <input type="number" class="max-bracket-sf" placeholder="Max SF" value="1200">
                        <select class="cost-type">
                            <option value="costPerSf">Cost/SF</option>
                            <option value="fixedCost">Fixed Cost</option>
                        </select>
                        <input type="number" class="cost-per-sf-input" placeholder="Cost/SF" value="9.35">
                        <input type="number" class="fixed-cost-input" placeholder="Fixed Cost" style="display: none;">
                        <button class="remove-bracket">Remove</button>
                    </div>
                    <div class="bracket-row">
                        <input type="number" class="min-bracket-sf" placeholder="Min SF" value="1201">
                        <input type="number" class="max-bracket-sf" placeholder="Max SF" value="1600">
                        <select class="cost-type">
                            <option value="costPerSf">Cost/SF</option>
                            <option value="fixedCost">Fixed Cost</option>
                        </select>
                        <input type="number" class="cost-per-sf-input" placeholder="Cost/SF" value="9.25">
                        <input type="number" class="fixed-cost-input" placeholder="Fixed Cost" style="display: none;">
                        <button class="remove-bracket">Remove</button>
                    </div>
                    <div class="bracket-row">
                        <input type="number" class="min-bracket-sf" placeholder="Min SF" value="1601">
                        <input type="number" class="max-bracket-sf" placeholder="Max SF">
                        <select class="cost-type">
                            <option value="costPerSf">Cost/SF</option>
                            <option value="fixedCost">Fixed Cost</option>
                        </select>
                        <input type="number" class="cost-per-sf-input" placeholder="Cost/SF" value="9.15">
                        <input type="number" class="fixed-cost-input" placeholder="Fixed Cost" style="display: none;">
                        <button class="remove-bracket">Remove</button>
                    </div>
                </div>

                <button id="modal-add-bracket">Add Bracket</button>
                <button id="modal-generate">Generate JavaScript Code</button>
                <button id="modal-use-formula">Use Formula</button>

                <h2>Generated Code</h2>
                <textarea id="modal-output" readonly></textarea>
            </div>
        </div>

        <div id="scope-templates-section" class="page-section">
            <h2>Scope of Work Templates</h2>
            <p>Manage reusable scope of work templates. Select a template on the Dashboard to pre-fill the Scope of Work
                text.
            </p>
            <table id="scope-templates-table">
                <thead>
                    <tr>
                        <th>Template Name (for Dropdown)</th>
                        <th>Scope Text</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="scope-templates-body"></tbody>
            </table>
            <button id="btn-add-scope-template" class="add-item-button">+ Add New Template</button>
            <div class="settings-actions">
                <button id="btn-save-scope-templates" class="save-button">Save Scope Templates</button>
                <span id="scope-templates-feedback" class="feedback-span"></span>
            </div>
            <div class="backup-restore-section">
                <h3>Settings Backup & Restore</h3>
                <p>Export the settings of the currently active profile to a JSON file, or import a profile from a file.
                </p>
                <button id="btn-export-settings-scopes" class="import-export-button">Export Active Profile</button>
                <button id="btn-import-settings-scopes" class="import-export-button">Import Profile from File</button>
                <input type="file" id="import-file-input-scopes" accept=".json" style="display: none;"> <span
                    id="backup-restore-feedback-scopes" class="feedback-span"></span>
            </div>
        </div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <script>
        // JavaScript Part 2 will start here...
        /**************************************************************************
 * JS_MAIN_HEADER START
 * CONCRETE ESTIMATOR TOOL - SUMMARY & STATUS (Updated!)
 **************************************************************************
 * GOAL: Create a simple, offline, single-file HTML/JS tool...
 * CURRENT STATUS: Cost Item Reordering, Prop Option Reordering, Formulas,
 * Live Costs, PDF Auto-Naming, Separate Adjustments/Optionals,
 * Internal PDF shows ALL selected items & scratchpad notes.
 * NEW PDFS: Letterhead, Field Quote, Subcontractor.
 * ENHANCEMENTS: Customizable proposal line color, signature lines.
 * KEY TECHNOLOGIES: HTML5, CSS3, JS, localStorage, jsPDF, jsPDF-AutoTable
 * NEXT STEP: Testing all PDF outputs and functionality.
 **************************************************************************/
        // JS_MAIN_HEADER END

        // === JS_CONSTANTS_DEFAULTS_GLOBALS START ===
        // --- Constants ---
        const ITEMS_STORAGE_KEY = 'concreteEstimator_items_v2';
        const MARKUP_STORAGE_KEY = 'concreteEstimator_markup';
        const PDF_CONFIG_STORAGE_KEY = 'concreteEstimator_pdfConfig_v2'; // Incremented version for new color setting
        const PROPOSAL_OPTIONS_KEY = 'concreteEstimator_options';
        const SCOPE_TEMPLATES_KEY = 'concreteEstimator_scopeTemplates';
        const MAX_LOGO_SIZE_BYTES = 2 * 1024 * 1024;
        const CONCRETE_WASTE_FACTOR = 1.10;
        const BACKUP_FILE_NAME = 'concrete_estimator_settings_v10.json'; // Incremented version
        const UNSAVED_CLASS = 'unsaved-changes';
        const INVALID_CLASS = 'invalid';
        const DEFAULT_PROPOSAL_LINE_COLOR = '#CCCCCC'; // Default light grey for proposal lines
        const PROFILES_LIST_KEY = 'concreteEstimator_profileNamesList_v1'; // Stores an array of profile names
        const ACTIVE_PROFILE_KEY = 'concreteEstimator_activeProfileName_v1'; // Stores the name of the last active profile
        const PROFILE_DATA_PREFIX = 'concreteEstimator_profileData_'; // Prefix for storing individual profile data objects
        const NO_PROFILE_SELECTED_VALUE = ""; // Value for the "-- No Profile Selected --" option
        const DASHBOARD_STATE_KEY = 'concreteEstimator_dashboardState_v1'; // Key for sessionStorage

        // --- Default Settings ---
        const defaultMarkup = 40;
        const defaultItems = [
            { name: "Prep w/ Tractor", pricingType: "Fixed", unit: "hours", cost: 75.00, formula: "", description: "Site preparation using tractor/equipment" },
            { name: "Prep by Hand", pricingType: "Fixed", unit: "hours", cost: 40.00, formula: "", description: "Manual site preparation/grading" },
            { name: "Finish Labor", pricingType: "Fixed", unit: "hours", cost: 55.00, formula: "", description: "Labor for placing and finishing concrete" },
            { name: "Concrete", pricingType: "Fixed", unit: "cu yd", cost: 180.00, formula: "", description: "Standard 4000 PSI concrete mix" },
            { name: "Rebar", pricingType: "Fixed", unit: "lbs", cost: 0.85, formula: "", description: "#4 (1/2\") Rebar, Grade 60" },
            { name: "Wire Mesh", pricingType: "Fixed", unit: "sq ft", cost: 0.30, formula: "", description: "6x6 W1.4/W1.4 Wire Mesh" },
            { name: "Macro Fiber", pricingType: "Fixed", unit: "lbs", cost: 5.00, formula: "", description: "Synthetic macrofiber reinforcement" },
            { name: "Micro Fiber", pricingType: "Fixed", unit: "lbs", cost: 4.00, formula: "", description: "Synthetic microfiber reinforcement" },
            { name: "Expansion Material", pricingType: "Fixed", unit: "lin ft", cost: 1.50, formula: "", description: "1/2\" Expansion joint material" },
            { name: "PVC Drain", pricingType: "Fixed", unit: "lin ft", cost: 4.50, formula: "", description: "Schedule 40 PVC drainage pipe & fittings (avg)" },
            { name: "Steps", pricingType: "Fixed", unit: "each", cost: 250.00, formula: "", description: "Forming and pouring standard concrete steps (per step)" },
            { name: "In Ground Pier", pricingType: "Fixed", unit: "each", cost: 150.00, formula: "", description: "Drilled/formed in-ground concrete pier (basic)" },
            { name: "Thick Edge", pricingType: "Fixed", unit: "lin ft", cost: 8.00, formula: "", description: "Formed thickened edge (e.g., 12\"x12\")" },
            { name: "Skidsteer", pricingType: "Fixed", unit: "hours", cost: 90.00, formula: "", description: "Skidsteer loader rental/operation" },
            { name: "Pump", pricingType: "Fixed", unit: "job", cost: 650.00, formula: "", description: "Concrete pump truck service (per job/day)" },
            { name: "Dump Fees", pricingType: "Fixed", unit: "job", cost: 100.00, formula: "", description: "Standard landfill dump fees (per load/job avg)" },
            { name: "Organic Dump Fees", pricingType: "Fixed", unit: "job", cost: 120.00, formula: "", description: "Dump fees for organic material (soil, etc.)" },
            { name: "Sawcuts", pricingType: "Fixed", unit: "lin ft", cost: 2.00, formula: "", description: "Control joint saw cutting" },
            { name: "Exposed Aggregate", pricingType: "Fixed", unit: "sq ft", cost: 3.50, formula: "", description: "Exposed aggregate finish application" },
            { name: "Fill", pricingType: "Fixed", unit: "cu yd", cost: 30.00, formula: "", description: "Imported fill material (gravel/sand)" }
        ];

        const defaultPdfConfig = {
            companyName: "Your Company Name",
            companyAddress: "123 Main St\nAnytown, ST 12345",
            companyContact: "your@email.com | 555-555-5555",
            defaultNotes: "Thank you for your business!\nPayment due upon completion unless otherwise noted.\n...",
            logoDataUrl: "",
            proposalLineColor: DEFAULT_PROPOSAL_LINE_COLOR,
            companyWebsiteUrl: "" // <-- ADD THIS LINE
        };

        const defaultProposalOptions = [ // These are now Adjustments/Options
            { id: `option_${Date.now()}_1`, name: "Standard Sealer", description: "Apply one coat of acrylic concrete sealer.", type: "Fixed", value: 350.00 }, // Could be optional
            { id: `option_${Date.now()}_2`, name: "Senior Discount", description: "Discount for clients aged 65+.", type: "Percent", value: -5 }, // Likely an adjustment
            { id: `option_${Date.now()}_3`, name: "Material Surcharge", description: "Adjustment for recent material cost increases.", type: "Percent", value: 3 } // Likely an adjustment
        ];

        const defaultScopeTemplates = [
            { id: `scope_${Date.now()}_1`, name: "Standard Driveway R&R", text: "Includes:\n- Removal and disposal of existing concrete driveway.\n- Grading and compaction of sub-base.\n- Installation of #4 rebar reinforcement grid (approx. 18\" O.C.).\n- Pouring 4\" thick, 4000 PSI concrete with broom finish.\n- Expansion joints installed where necessary.\n- Control joint saw cutting.\n- Site cleanup upon completion." },
            { id: `scope_${Date.now()}_2`, name: "Basic Patio Slab", text: "Includes:\n- Minor grading of installation area.\n- Forming for new concrete patio.\n- Installation of wire mesh reinforcement.\n- Pouring 4\" thick, 4000 PSI concrete with broom finish.\n- Control joint saw cutting.\n- Site cleanup." }
        ];

        // --- Global Variables ---
        let currentItems = [];
        let currentMarkup = defaultMarkup;
        let currentPdfConfig = { ...defaultPdfConfig };
        let currentProposalOptions = []; // Holds both adjustments and options definitions
        let currentScopeTemplates = [];
        let currentProfileName = null; // Name of the currently loaded profile
        let profileNamesList = []; // Array to hold all profile names
        let isProfileDirty = false; // Flag to track unsaved changes in the active profile
        // === JS_CONSTANTS_DEFAULTS_GLOBALS END ===
        // === JS_DOM_REFS START ===
        // --- DOM References ---
        // NEW Profile Management DOM References
        const profileManagementControlsDiv = document.getElementById('profile-management-controls');
        const profileSelectDropdown = document.getElementById('profile-select');
        const profileNewNameInput = document.getElementById('profile-new-name');
        const btnCreateProfile = document.getElementById('btn-create-profile');
        const btnRenameProfile = document.getElementById('btn-rename-profile');
        const btnDeleteProfile = document.getElementById('btn-delete-profile');
        const profileFeedbackSpan = document.getElementById('profile-feedback');
        // Navigation & Sections
        const btnDashboard = document.getElementById('btn-dashboard');
        const btnCostItems = document.getElementById('btn-cost-items');
        const btnPdfSettings = document.getElementById('btn-pdf-settings');
        const btnProposalOptions = document.getElementById('btn-proposal-options');
        const btnScopeTemplates = document.getElementById('btn-scope-templates');
        const costItemsSection = document.getElementById('cost-items-section');
        const pdfSettingsSection = document.getElementById('pdf-settings-section');
        const proposalOptionsSection = document.getElementById('proposal-options-section');
        const scopeTemplatesSection = document.getElementById('scope-templates-section');
        const dashboardSection = document.getElementById('dashboard-section');
        const navButtons = document.querySelectorAll('.navigation button');
        const pageSections = document.querySelectorAll('.page-section');
        // Dashboard Inputs & Displays
        const clientNameInput = document.getElementById('client-name');
        const projectInfoInput = document.getElementById('project-info');
        const scopeTemplateSelect = document.getElementById('scope-template-select');
        const scopeOfWorkInput = document.getElementById('scope-of-work');
        const scopeOfWorkValidationError = document.getElementById('scope-of-work-validation-error');
        const jobAreaInput = document.getElementById('job-area');
        const jobThicknessInput = document.getElementById('job-thickness');
        const calculatedConcreteVolumeEl = document.getElementById('calculated-concrete-volume');
        const dashboardItemsDiv = document.getElementById('dashboard-items');
        const dashboardOptionsDiv = document.getElementById('dashboard-options');
        const dashboardScratchpad = document.getElementById('dashboard-scratchpad');
        // Dashboard Buttons
        const btnClearQuantities = document.getElementById('btn-clear-quantities');
        const btnClearJobInfo = document.getElementById('btn-clear-job-info');
        // PDF Buttons (Updated)
        const btnGenerateInternalPDF = document.getElementById('btn-generate-internal-pdf');
        const btnGenerateProposalPDF = document.getElementById('btn-generate-proposal-pdf');
        const btnGenerateLetterheadPDF = document.getElementById('btn-generate-letterhead-pdf'); // New
        const btnGenerateFieldQuotePDF = document.getElementById('btn-generate-field-quote-pdf'); // New
        const btnGenerateSubcontractorPDF = document.getElementById('btn-generate-subcontractor-pdf'); // New
        // Running Totals Display
        const runningSubtotalEl = document.getElementById('running-subtotal');
        const runningMarkupPercentEl = document.getElementById('running-markup-percent');
        const runningMarkupAmountEl = document.getElementById('running-markup-amount');
        const runningTotalBeforeOptionsEl = document.getElementById('running-total-before-options');
        const runningOptionsAdjustmentEl = document.getElementById('running-options-adjustment'); // Now shows ADJUSTMENTS total
        const runningGrandTotalEl = document.getElementById('running-grand-total'); // Base + Markup + Adjustments
        const runningFranchiseFeeEl = document.getElementById('running-franchise-fee');
        const runningProfitAfterFeeEl = document.getElementById('running-profit-after-fee');
        const runningPricePerSqftEl = document.getElementById('running-price-per-sqft');
        // Optional Additions Display (New)
        const dashboardOptionalAdditionsDiv = document.getElementById('dashboard-optional-additions');
        const dashboardOptionalItemsListDiv = document.getElementById('dashboard-optional-items-list');
        // Cost Items Settings
        const markupInput = document.getElementById('markup');
        const markupValidationError = document.getElementById('markup-validation-error');
        const settingsItemsBody = document.getElementById('settings-items-body');
        const btnAddItem = document.getElementById('btn-add-item');
        const btnSaveCostItems = document.getElementById('btn-save-cost-items');
        const costItemsFeedback = document.getElementById('cost-items-feedback');
        // PDF Settings
        const pdfCompanyNameInput = document.getElementById('pdf-company-name');
        const pdfCompanyAddressInput = document.getElementById('pdf-company-address');
        const pdfCompanyContactInput = document.getElementById('pdf-company-contact');
        const pdfDefaultNotesInput = document.getElementById('pdf-default-notes');
        const pdfProposalLineColorInput = document.getElementById('pdf-proposal-line-color'); // New
        const btnSavePdfSettings = document.getElementById('btn-save-pdf-settings');
        const pdfSettingsFeedback = document.getElementById('pdf-settings-feedback');
        const pdfLogoFileInput = document.getElementById('pdf-logo-file');
        const logoPreview = document.getElementById('logo-preview');
        const logoStatus = document.getElementById('logo-status');
        // Proposal Options Settings
        const proposalOptionsBody = document.getElementById('proposal-options-body');
        const btnAddOption = document.getElementById('btn-add-option');
        const btnSaveOptions = document.getElementById('btn-save-options');
        const optionsFeedback = document.getElementById('options-feedback');
        // Scope Templates Settings
        const scopeTemplatesBody = document.getElementById('scope-templates-body');
        const btnAddScopeTemplate = document.getElementById('btn-add-scope-template');
        const btnSaveScopeTemplates = document.getElementById('btn-save-scope-templates');
        const scopeTemplatesFeedback = document.getElementById('scope-templates-feedback');
        // Feedback Spans (PDF Gen - Updated)
        const internalPdfFeedback = document.getElementById('internal-pdf-feedback');
        const proposalPdfFeedback = document.getElementById('proposal-pdf-feedback');
        const letterheadPdfFeedback = document.getElementById('letterhead-pdf-feedback'); // New
        const fieldQuotePdfFeedback = document.getElementById('field-quote-pdf-feedback'); // New
        const subcontractorPdfFeedback = document.getElementById('subcontractor-pdf-feedback'); // New
        // Backup / Restore Elements
        const btnExportSettings = document.getElementById('btn-export-settings');
        const btnImportSettings = document.getElementById('btn-import-settings');
        const importFileInput = document.getElementById('import-file-input');
        const backupRestoreFeedback = document.getElementById('backup-restore-feedback');
        const btnExportSettingsPdf = document.getElementById('btn-export-settings-pdf');
        const btnImportSettingsPdf = document.getElementById('btn-import-settings-pdf');
        const backupRestoreFeedbackPdf = document.getElementById('backup-restore-feedback-pdf');
        const btnExportSettingsOptions = document.getElementById('btn-export-settings-options');
        const btnImportSettingsOptions = document.getElementById('btn-import-settings-options');
        const backupRestoreFeedbackOptions = document.getElementById('backup-restore-feedback-options');
        const btnExportSettingsScopes = document.getElementById('btn-export-settings-scopes');
        const btnImportSettingsScopes = document.getElementById('btn-import-settings-scopes');
        const backupRestoreFeedbackScopes = document.getElementById('backup-restore-feedback-scopes');
        // NEW Temporary Item DOM References
        const dashboardTempItemsDiv = document.getElementById('dashboard-temp-items');
        const btnAddTempItem = document.getElementById('btn-add-temp-item');
        // NEW Temporary Option DOM References
        const dashboardTempOptionsDiv = document.getElementById('dashboard-temp-options');
        const btnAddTempOption = document.getElementById('btn-add-temp-option');
        // Error Display
        const initializationErrorDisplay = document.getElementById('initialization-error-display');
        // === JS_DOM_REFS END ===
        // === JS_UTILITIES START ===
        // --- Utility Functions ---
        function formatCurrency(amount) {
            const numAmount = Number(amount);
            if (isNaN(numAmount)) { console.warn("formatCurrency received non-numeric value:", amount); return "$NaN"; }
            return numAmount.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
        }

        function openFormulaGeneratorModal(itemIndex) {
            const modal = document.getElementById('formula-generator-modal');
            if (modal) {
                modal.style.display = 'block';

                // Find the button that was clicked
                const openingButton = document.querySelector(`#btn-generate-formula-${itemIndex}`);
                if (openingButton) {
                    // Add a class to the button to mark it as the active button
                    openingButton.classList.add('active-generator-button');
                }

                // --- PRE-FILL MODAL INPUTS --- (Modified)
                const minTotalCostInput = modal.querySelector('#modal-minTotalCost');
                const flatCostInput = modal.querySelector('#modal-flatCost');
                const bracketsDiv = modal.querySelector('#modal-brackets');
                const outputTextarea = modal.querySelector('#modal-output');

                // Clear existing brackets
                bracketsDiv.innerHTML = '';

                if (Array.isArray(currentItems) && itemIndex >= 0 && itemIndex < currentItems.length) {
                    const item = currentItems[itemIndex];
                    if (item.formulaGeneratorState) {
                        const state = item.formulaGeneratorState;
                        minTotalCostInput.value = state.minTotalCost || 1500;
                        flatCostInput.value = state.flatCost || 0;

                        if (Array.isArray(state.brackets)) {
                            state.brackets.forEach(bracket => {
                                addBracketToModal(bracketsDiv, bracket);
                            });
                        } else {
                            // Add default brackets if none in state
                            addBracketToModal(bracketsDiv, { minSf: 1, maxSf: 250, costType: 'costPerSf', costValue: 10 });
                            addBracketToModal(bracketsDiv, { minSf: 251, maxSf: 350, costType: 'costPerSf', costValue: 9.85 });
                            addBracketToModal(bracketsDiv, { minSf: 351, maxSf: 499, costType: 'costPerSf', costValue: 9.65 });
                            addBracketToModal(bracketsDiv, { minSf: 500, maxSf: 650, costType: 'costPerSf', costValue: 9.55 });
                            addBracketToModal(bracketsDiv, { minSf: 651, maxSf: 800, costType: 'costPerSf', costValue: 9.45 });
                            addBracketToModal(bracketsDiv, { minSf: 801, maxSf: 1200, costType: 'costPerSf', costValue: 9.35 });
                            addBracketToModal(bracketsDiv, { minSf: 1201, maxSf: 1600, costType: 'costPerSf', costValue: 9.25 });
                            addBracketToModal(bracketsDiv, { minSf: 1601, maxSf: null, costType: 'costPerSf', costValue: 9.15 });
                        }

                        // Trigger code generation to show existing formula
                        generateJavaScriptCode(bracketsDiv, minTotalCostInput, flatCostInput, outputTextarea);
                    } else {
                        //If no formulaGeneratorState, add default brackets
                        addBracketToModal(bracketsDiv, { minSf: 1, maxSf: 250, costType: 'costPerSf', costValue: 10 });
                        addBracketToModal(bracketsDiv, { minSf: 251, maxSf: 350, costType: 'costPerSf', costValue: 9.85 });
                        addBracketToModal(bracketsDiv, { minSf: 351, maxSf: 499, costType: 'costPerSf', costValue: 9.65 });
                        addBracketToModal(bracketsDiv, { minSf: 500, maxSf: 650, costType: 'costPerSf', costValue: 9.55 });
                        addBracketToModal(bracketsDiv, { minSf: 651, maxSf: 800, costType: 'costPerSf', costValue: 9.45 });
                        addBracketToModal(bracketsDiv, { minSf: 801, maxSf: 1200, costType: 'costPerSf', costValue: 9.35 });
                        addBracketToModal(bracketsDiv, { minSf: 1201, maxSf: 1600, costType: 'costPerSf', costValue: 9.25 });
                        addBracketToModal(bracketsDiv, { minSf: 1601, maxSf: null, costType: 'costPerSf', costValue: 9.15 });
                        generateJavaScriptCode(bracketsDiv, minTotalCostInput, flatCostInput, outputTextarea);
                    }

                } else {
                    console.error("Invalid item index or currentItems array.");
                }
                // --- END PRE-FILL ---
            } else {
                console.error("Formula generator modal not found.");
            }
        }

        // 4. Event Listener for "Generate"
        const modalGenerateButton = document.getElementById('modal-generate');
        if (modalGenerateButton) {
            modalGenerateButton.addEventListener('click', () => {
                const modalBracketsDiv = document.getElementById('modal-brackets');
                const modalMinTotalCostInput = document.getElementById('modal-minTotalCost');
                const modalFlatCostInput = document.getElementById('modal-flatCost');
                const modalOutputTextarea = document.getElementById('modal-output');
                const generatedCode = generateJavaScriptCode(modalBracketsDiv, modalMinTotalCostInput, modalFlatCostInput, modalOutputTextarea);
                modalOutputTextarea.value = generatedCode;
            });
        } else {
            console.error("Modal 'Generate' button not found.");
        }

        // 5. Add event listener for the "Use Formula" button
        const modalUseFormulaButton = document.getElementById('modal-use-formula');
        if (modalUseFormulaButton) {
            modalUseFormulaButton.addEventListener('click', () => {
                const modal = document.getElementById('formula-generator-modal');
                const formula = document.getElementById('modal-output').value;
                if (formula) {
                    // Find the button that opened the modal
                    const openingButton = document.querySelector('.generate-formula-button.active-generator-button');
                    if (openingButton) {
                        // Find the input field in the same table cell
                        const inputFormula = openingButton.previousElementSibling; // Assuming input is *before* the button
                        if (inputFormula && inputFormula.classList.contains('item-formula')) {
                            inputFormula.value = formula;
                            inputFormula.dispatchEvent(new Event('input', { bubbles: true })); // Trigger input event
                            modal.style.display = 'none'; // Close modal
                        } else {
                            console.warn("Could not find the associated inputFormula field.");
                            alert("Error: Could not find the correct formula input field.");
                        }
                        // Remove the active class
                        openingButton.classList.remove('active-generator-button');
                    } else {
                        console.warn("Could not determine which button opened the modal.");
                        alert("Error: Please open the formula generator from a valid formula input field.");
                    }
                }
            });
        } else {
            console.error("Modal 'Use Formula' button not found.");
        }

        // 6. Event listener for the modal's close button
        const modalCloseButton = document.querySelector('#formula-generator-modal .close');
        if (modalCloseButton) {
            modalCloseButton.addEventListener('click', () => {
                document.getElementById('formula-generator-modal').style.display = 'none';
            });
        } else {
            console.error("Modal close button not found.");
        }

        // 7. Event listener for adding bracket
        const modalAddBracketButton = document.getElementById('modal-add-bracket');
        if (modalAddBracketButton) {
            modalAddBracketButton.addEventListener('click', () => {
                const bracketsDiv = document.getElementById('modal-brackets');
                addBracketToModal(bracketsDiv, { minSf: 0, maxSf: null, costType: 'costPerSf', costValue: 10 });
            });
        } else {
            console.error("Modal 'Add Bracket' button not found.");
        }

        function addBracketToModal(bracketsDiv, bracket) {
            const newBracketRow = document.createElement('div');
            newBracketRow.classList.add('bracket-row');
            newBracketRow.innerHTML = `
        <input type="number" class="min-bracket-sf" placeholder="Min SF" value="${bracket.minSf || 0}">
        <input type="number" class="max-bracket-sf" placeholder="Max SF" value="${bracket.maxSf || ''}">
        <select class="cost-type">
            <option value="costPerSf" ${bracket.costType === 'costPerSf' ? 'selected' : ''}>Cost/SF</option>
            <option value="fixedCost" ${bracket.costType === 'fixedCost' ? 'selected' : ''}>Fixed Cost</option>
        </select>
        <input type="number" class="cost-per-sf-input" placeholder="Cost/SF" value="${bracket.costValue || 10}" style="display: ${bracket.costType === 'costPerSf' ? 'block' : 'none'}">
        <input type="number" class="fixed-cost-input" placeholder="Fixed Cost" value="${bracket.costValue || 0}" style="display: ${bracket.costType === 'fixedCost' ? 'block' : 'none'}">
        <button class="remove-bracket">Remove</button>
    `;
            bracketsDiv.appendChild(newBracketRow);

            // Event listener for the "Remove" button of the *new* row
            const removeButton = newBracketRow.querySelector('.remove-bracket');
            removeButton.addEventListener('click', () => {
                newBracketRow.remove();
            });

            // Event listener for the cost type change of the *new* row
            const costTypeSelect = newBracketRow.querySelector('.cost-type');
            const costPerSfInput = newBracketRow.querySelector('.cost-per-sf-input');
            const fixedCostInput = newBracketRow.querySelector('.fixed-cost-input');

            costTypeSelect.addEventListener('change', () => {
                if (costTypeSelect.value === 'costPerSf') {
                    costPerSfInput.style.display = 'block';
                    fixedCostInput.style.display = 'none';
                } else {
                    costPerSfInput.style.display = 'none';
                    fixedCostInput.style.display = 'block';
                }
            });
        }

        function generateJavaScriptCode(bracketsDiv, minTotalCostInput, flatCostInput, outputTextarea) {
            const minTotalCost = parseFloat(minTotalCostInput.value);
            const flatCost = parseFloat(flatCostInput.value) || 0;
            const brackets = [];

            // Get bracket data from the DOM
            const bracketRows = bracketsDiv.querySelectorAll('.bracket-row');
            bracketRows.forEach(row => {
                const minBracketSf = parseFloat(row.querySelector('.min-bracket-sf').value);
                const maxBracketSf = row.querySelector('.max-bracket-sf').value === "" ? Infinity : parseFloat(row.querySelector('.max-bracket-sf').value);
                const costType = row.querySelector('.cost-type').value;
                let costValue;
                if (costType === 'costPerSf') {
                    costValue = parseFloat(row.querySelector('.cost-per-sf-input').value);
                } else {
                    costValue = parseFloat(row.querySelector('.fixed-cost-input').value);
                }

                if (!isNaN(minBracketSf) && !isNaN(costValue)) {
                    brackets.push({
                        minSf: minBracketSf,
                        maxSf: maxBracketSf,
                        costType: costType,
                        costValue: costValue
                    });
                }
            });

            let code = "";

            // Build the nested ternary expression
            code = `(quantity >= 0 ? `; // Start with the non-negative check

            brackets.forEach((bracket, index) => {
                code += `(quantity >= ${bracket.minSf}`;
                if (bracket.maxSf !== Infinity) {
                    code += ` && quantity <= ${bracket.maxSf}`;
                }
                code += ` ? `;
                if (bracket.costType === 'costPerSf') {
                    code += `quantity * ${bracket.costValue} + ${flatCost} : `;
                } else {
                    code += `${bracket.costValue} : `;
                }
            });

            // Handle default cost (if no bracket matches)
            let endDefault = `(quantity * 0 + ${flatCost})`; // Or a more appropriate default
            if (brackets.length > 0 && brackets[brackets.length - 1].maxSf === Infinity && brackets[brackets.length - 1].costType === 'costPerSf') {
                endDefault = `(quantity * ${brackets[brackets.length - 1].costValue} + ${flatCost})`;
            } else if (brackets.length > 0 && brackets[brackets.length - 1].maxSf === Infinity && brackets[brackets.length - 1].costType === 'fixedCost') {
                endDefault = `${brackets[brackets.length - 1].costValue}`;
            }
            code += `${endDefault}`;

            for (let i = 0; i < brackets.length; i++) {
                code += ")";
            }

            code += ` : 0)`; // Close the initial quantity check

            // Add the minTotalCost check *outside* the bracket calculation
            if (!isNaN(minTotalCost)) {
                code = `(${code} < ${minTotalCost} ? ${minTotalCost} : ${code})`;
            }

            return code;
        }

        function showFeedback(feedbackElement, message, color = 'green', duration = 3000) {
            if (!feedbackElement) { console.warn("Feedback element missing for message:", message); return; }
            feedbackElement.textContent = message;
            feedbackElement.style.color = color;
            feedbackElement.style.display = 'inline-block'; /* Ensure visible */
            if (duration > 0) {
                // Clear previous timeout if exists for this element
                if (feedbackElement.timeoutId) { clearTimeout(feedbackElement.timeoutId); }
                feedbackElement.timeoutId = setTimeout(() => {
                    if (feedbackElement && feedbackElement.textContent === message) { // Only clear if message hasn't changed
                        feedbackElement.textContent = '';
                        feedbackElement.style.display = 'none'; /* Hide after duration */
                    }
                    feedbackElement.timeoutId = null; // Clear the stored timeout ID
                }, duration);
            } else {
                // If duration is 0 or negative, clear any existing timeout immediately
                if (feedbackElement.timeoutId) { clearTimeout(feedbackElement.timeoutId); feedbackElement.timeoutId = null; }
            }
        }

        function showBackupRestoreFeedback(message, color = 'green', duration = 3000) {
            showFeedback(backupRestoreFeedback, message, color, duration);
            showFeedback(backupRestoreFeedbackPdf, message, color, duration);
            showFeedback(backupRestoreFeedbackOptions, message, color, duration);
            showFeedback(backupRestoreFeedbackScopes, message, color, duration);
        }

        function generateOptionId() {
            return `option_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`;
        }
        function generateTempItemId() {
            return `temp_item_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`;
        }
        function generateTempOptionId() { // NEW
            return `temp_option_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`;
        }
        function addTempItemToDashboard(tempItem = { id: generateTempItemId(), name: '', cost: 0, description: '', quantity: '' }) {
            if (!dashboardTempItemsDiv) { console.error("dashboardTempItemsDiv not found."); return; }

            // If it's the first temp item, remove the "No temporary items" message
            if (dashboardTempItemsDiv.querySelector('p')?.textContent === 'No temporary items added.') {
                dashboardTempItemsDiv.innerHTML = '';
            }

            const itemContainer = document.createElement('div');
            itemContainer.className = 'dashboard-item-container'; // Reuse existing styling
            itemContainer.setAttribute('data-temp-item-id', tempItem.id);

            // Re-structured innerHTML to match the "permanent" dashboard items more closely
            itemContainer.innerHTML = `
                <div class="dashboard-item-label">
                    <input type="text" class="temp-item-name" placeholder="Item Name" value="${tempItem.name || ''}"
                        style="width: 200px; font-weight: bold; margin-right: 10px;">
                </div>
                <div class="dashboard-item-input">
                    <input type="number" class="temp-item-cost" placeholder="Cost" value="${tempItem.cost || 0}" min="0" step="0.01"
                        style="width: 80px; margin-right: 5px; text-align: right;">
                    <span>x</span>
                    <input type="number" class="temp-item-quantity" placeholder="Qty" value="${tempItem.quantity || ''}" min="0" step="any"
                        style="width: 60px; margin-left: 5px;">
                    <span class="dashboard-line-total" style="margin-left: 10px; padding-top: 0; min-width: 90px; text-align: right;">${formatCurrency(0)}</span>
                </div>
                <div class="dashboard-item-desc" style="flex-grow: 1; padding-top: 0; min-width: 150px; margin-left: 10px;">
                    <textarea class="temp-item-description" placeholder="Description (optional)" rows="1"
                        style="width: 100%; font-size: 0.9em; min-height: 20px; box-sizing: border-box; resize: vertical;">${tempItem.description || ''}</textarea>
                </div>
                <div style="margin-left: 10px; padding-top: 8px;">
                    <button class="delete-button delete-temp-item-button" style="padding: 2px 5px; font-size: 0.85em;">Del</button>
                </div>
            `;
            dashboardTempItemsDiv.appendChild(itemContainer);

            // Get references to the newly created elements for event listeners
            const quantityInput = itemContainer.querySelector('.temp-item-quantity');
            const costInput = itemContainer.querySelector('.temp-item-cost');
            const nameInput = itemContainer.querySelector('.temp-item-name');
            const descInput = itemContainer.querySelector('.temp-item-description');
            const deleteButton = itemContainer.querySelector('.delete-temp-item-button');
            const lineTotalSpan = itemContainer.querySelector('.dashboard-line-total');

            // Function to update single temporary item line cost
            const updateSingleTempItemLineCost = () => {
                const qty = parseFloat(quantityInput.value) || 0;
                const cost = parseFloat(costInput.value) || 0;
                const total = qty * cost;
                lineTotalSpan.textContent = formatCurrency(total);
                updateRunningTotals(); // Re-calculate overall totals
                saveDashboardStateToSession(); // Save state on any input
            };

            quantityInput.addEventListener('input', updateSingleTempItemLineCost);
            costInput.addEventListener('input', updateSingleTempItemLineCost);
            nameInput.addEventListener('input', saveDashboardStateToSession);
            descInput.addEventListener('input', saveDashboardStateToSession);

            deleteButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to remove this temporary item?')) {
                    itemContainer.remove();
                    if (dashboardTempItemsDiv.children.length === 0) {
                        dashboardTempItemsDiv.innerHTML = '<p><i>No temporary items added.</i></p>';
                    }
                    updateRunningTotals(); // Re-calculate overall totals
                    saveDashboardStateToSession(); // Save state after deletion
                }
            });

            updateSingleTempItemLineCost(); // Initial calculation
        }
        function addTempOptionToDashboard(tempOption = { id: generateTempOptionId(), name: '', description: '', type: 'Fixed', value: 0, applyMarkup: false, isOptional: false, showOnQuote: true }) { // ADD showOnQuote to default
            if (!dashboardTempOptionsDiv) { console.error("dashboardTempOptionsDiv not found."); return; }

            // If it's the first temp option, remove the "No temporary options" message
            if (dashboardTempOptionsDiv.querySelector('p')?.textContent === 'No temporary options added.') {
                dashboardTempOptionsDiv.innerHTML = '';
            }

            const optionContainer = document.createElement('div');
            optionContainer.className = 'dashboard-option-item'; // Reuse existing styling
            optionContainer.setAttribute('data-temp-option-id', tempOption.id);

            // Adjusted innerHTML:
            // 1. Added 'option-dashboard-show-toggle' equivalent for temp options.
            // 2. Added new container div for "Apply Markup?" and "Make Optional?" for better grouping.
            // 3. Removed previous 'disabled' logic for applyMarkupCheckbox.
            optionContainer.innerHTML = `
                <div class="label-container" style="width: 180px; flex-shrink: 0; margin-right: 15px;">
                    <input type="text" class="temp-option-name" placeholder="Name" value="${tempOption.name || ''}"
                        style="width: 100%; font-weight: bold; margin-bottom: 5px; box-sizing: border-box;">
                    <textarea class="temp-option-description" placeholder="Description (optional)" rows="1"
                        style="width: 100%; font-size: 0.8em; min-height: 18px; box-sizing: border-box; resize: vertical;">${tempOption.description || ''}</textarea>
                </div>

                <div class="value-container" style="display: flex; align-items: center; max-width: 200px; margin-right: 15px; flex-shrink: 0;">
                    <select class="temp-option-type" style="width: 70px; margin-right: 5px; font-size: 0.9em;">
                        <option value="Fixed" ${tempOption.type === 'Fixed' ? 'selected' : ''}>Fixed</option>
                        <option value="Percent" ${tempOption.type === 'Percent' ? 'selected' : ''}>Percent</option>
                    </select>
                    <input type="number" class="temp-option-value" placeholder="Value" value="${tempOption.value || 0}"
                        min="${tempOption.type === 'Percent' ? '-100' : ''}" step="any"
                        style="width: 80px; text-align: right;">
                    <span class="value-type-indicator" style="margin-left: 5px; font-weight: bold;">${tempOption.type === 'Percent' ? '%' : '$'}</span>
                </div>

                <div style="display: flex; flex-direction: column; justify-content: center; margin-right: 15px; flex-shrink: 0; min-width: 120px;">
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <input type="checkbox" class="temp-option-apply-markup" id="temp-option-apply-markup-${tempOption.id}" ${tempOption.applyMarkup ? 'checked' : ''}
                            style="transform: scale(1.1); margin-right: 5px; flex-shrink: 0;">
                        <label for="temp-option-apply-markup-${tempOption.id}"
                            style="font-weight: normal; margin-bottom: 0; padding-top: 0; display: inline; font-size: 0.9em; flex-grow: 1;"
                            title="If checked, the markup percentage will be applied to this adjustment's value.">Apply Markup?</label>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <input type="checkbox" class="temp-option-is-optional" id="temp-option-is-optional-${tempOption.id}" ${tempOption.isOptional ? 'checked' : ''}
                            style="transform: scale(1.1); margin-right: 5px; flex-shrink: 0;">
                        <label for="temp-option-is-optional-${tempOption.id}"
                            style="font-weight: normal; margin-bottom: 0; padding-top: 0; display: inline; font-size: 0.9em; flex-grow: 1;"
                            title="If checked, this item will be listed as an Optional Addition and not included in the main total.">Make Optional?</label>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <input type="checkbox" class="temp-option-show-on-quote" id="temp-option-show-on-quote-${tempOption.id}" ${tempOption.showOnQuote ? 'checked' : ''}
                            style="transform: scale(1.1); margin-right: 5px; flex-shrink: 0;">
                        <label for="temp-option-show-on-quote-${tempOption.id}"
                            style="font-weight: normal; margin-bottom: 0; padding-top: 0; display: inline; font-size: 0.9em; flex-grow: 1;"
                            title="If checked, this item will be displayed on the customer proposal PDF.">Show on Quote?</label>
                    </div>
                </div>

                <div style="margin-left: auto; padding-top: 5px; flex-shrink: 0;">
                    <button class="delete-button delete-temp-option-button" style="padding: 2px 5px; font-size: 0.85em;">Del</button>
                </div>
            `;
            dashboardTempOptionsDiv.appendChild(optionContainer);

            // Get references and attach event listeners
            const nameInput = optionContainer.querySelector('.temp-option-name');
            const descInput = optionContainer.querySelector('.temp-option-description');
            const typeSelect = optionContainer.querySelector('.temp-option-type');
            const valueInput = optionContainer.querySelector('.temp-option-value');
            const typeIndicator = optionContainer.querySelector('.value-type-indicator');
            const applyMarkupCheckbox = optionContainer.querySelector('.temp-option-apply-markup');
            const isOptionalCheckbox = optionContainer.querySelector('.temp-option-is-optional');
            const showOnQuoteCheckbox = optionContainer.querySelector('.temp-option-show-on-quote'); // NEW: Show on Quote checkbox reference
            const deleteButton = optionContainer.querySelector('.delete-temp-option-button');

            // Store the original value to apply markup calculations
            let originalValueForMarkup = parseFloat(tempOption.value) || 0;
            // Store the current display value of the input for comparison
            let currentDisplayValue = originalValueForMarkup;


            const updateTempOptionDisplay = (eventSource = null) => {
                const markupRate = (parseFloat(currentMarkup) || 0) / 100; // Get current global markup rate

                // Update Type Indicator
                typeIndicator.textContent = typeSelect.value === 'Percent' ? '%' : '$';
                valueInput.min = typeSelect.value === 'Percent' ? '-100' : 'any';

                // If the value input itself was changed, update originalValueForMarkup
                if (eventSource === valueInput) {
                    originalValueForMarkup = parseFloat(valueInput.value) || 0;
                }

                let newValueToDisplay = originalValueForMarkup;
                if (typeSelect.value === 'Fixed' && applyMarkupCheckbox.checked) {
                    newValueToDisplay = originalValueForMarkup * (1 + markupRate);
                }
                // Update the input field's value display
                // Only update if the value is different to prevent cursor jump issues
                if (parseFloat(valueInput.value) !== parseFloat(newValueToDisplay.toFixed(2))) { // Use toFixed(2) for comparison
                    valueInput.value = newValueToDisplay.toFixed(2);
                }

                updateRunningTotals(); // Recalculate when anything changes
                saveDashboardStateToSession(); // Save state
            };

            // Event Listeners:
            // Input changes directly update originalValueForMarkup and then trigger display update
            nameInput.addEventListener('input', () => updateTempOptionDisplay(nameInput));
            descInput.addEventListener('input', () => updateTempOptionDisplay(descInput));
            typeSelect.addEventListener('change', () => updateTempOptionDisplay(typeSelect));
            valueInput.addEventListener('input', () => updateTempOptionDisplay(valueInput)); // Pass valueInput as eventSource
            applyMarkupCheckbox.addEventListener('change', () => updateTempOptionDisplay(applyMarkupCheckbox)); // Pass checkbox as eventSource
            isOptionalCheckbox.addEventListener('change', () => updateTempOptionDisplay(isOptionalCheckbox));
            showOnQuoteCheckbox.addEventListener('change', () => saveDashboardStateToSession()); // Show on Quote only needs to save state

            deleteButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to remove this temporary adjustment?')) {
                    optionContainer.remove();
                    if (dashboardTempOptionsDiv.children.length === 0) {
                        dashboardTempOptionsDiv.innerHTML = '<p><i>No temporary options added.</i></p>';
                    }
                    updateRunningTotals(); // Recalculate overall totals
                    saveDashboardStateToSession(); // Save state after deletion
                }
            });

            updateTempOptionDisplay(); // Initial calculation and display update on load/add
        }
        function generateScopeId() { return `scope_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`; }

        function clearValidationErrors(sectionElement) {
            if (!sectionElement) return;
            sectionElement.querySelectorAll(`.${INVALID_CLASS}`).forEach(el => el.classList.remove(INVALID_CLASS));
            sectionElement.querySelectorAll('.validation-error-message').forEach(el => {
                el.textContent = '';
                el.style.display = 'none';
            });
            // Clear feedback spans if they show validation errors
            sectionElement.querySelectorAll('.settings-actions .feedback-span, .pdf-actions .feedback-span').forEach(span => {
                if (span.textContent.startsWith("Validation error") || span.textContent.includes("required for")) {
                    span.textContent = '';
                    span.style.display = 'none';
                }
            });
        }

        function setSaveButtonState(buttonElement, hasUnsavedChanges) {
            if (!buttonElement) return;
            if (hasUnsavedChanges) {
                buttonElement.classList.add(UNSAVED_CLASS);
            } else {
                buttonElement.classList.remove(UNSAVED_CLASS);
            }
        }

        function sanitizeForFilename(text) {
            if (typeof text !== 'string') return '';
            let sanitized = text.replace(/[\\/*?:"<>|]/g, ""); // Remove invalid filename chars
            sanitized = sanitized.replace(/[\s_]+/g, "_"); // Replace spaces/underscores with single underscore
            sanitized = sanitized.replace(/^_+|_+$/g, ''); // Trim leading/trailing underscores
            return sanitized.substring(0, 50); // Limit length
        }

        // Helper to safely get jsPDF instance
        function getJsPDF() {
            if (typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined') {
                console.error("jsPDF library not found.");
                alert("Error: jsPDF library is not loaded. Cannot generate PDF.");
                return null;
            }
            // Check for AutoTable plugin
            if (typeof window.jspdf.jsPDF.autoTable !== 'function') {
                console.warn("jsPDF AutoTable plugin not found. Tables will use basic text layout.");
                // Optionally provide feedback to user or disable features
            }
            const { jsPDF } = window.jspdf;
            return new jsPDF();
        }
        function getProfileNamesFromStorage() {
            const storedNames = localStorage.getItem(PROFILES_LIST_KEY);
            if (storedNames) {
                try {
                    const names = JSON.parse(storedNames);
                    return Array.isArray(names) ? names : [];
                } catch (e) {
                    console.error("Error parsing profile names from localStorage:", e);
                    return []; // Return empty if parsing fails
                }
            }
            return []; // Return empty if no names are stored
        }

        // NEW: Function to save the list of profile names to localStorage
        function saveProfileNamesToStorage(namesArray) {
            try {
                localStorage.setItem(PROFILES_LIST_KEY, JSON.stringify(namesArray));
            } catch (e) {
                console.error("Error saving profile names to localStorage:", e);
                // Potentially show an error to the user if localStorage is full or unwritable
                showFeedback(document.getElementById('profile-feedback'), "Error saving profile list!", "red");
            }
        }

        // NEW: Function to get the active profile name from localStorage
        function getActiveProfileNameFromStorage() {
            return localStorage.getItem(ACTIVE_PROFILE_KEY);
        }

        // NEW: Function to save the active profile name to localStorage
        function saveActiveProfileNameToStorage(profileName) {
            if (profileName) {
                localStorage.setItem(ACTIVE_PROFILE_KEY, profileName);
            } else {
                localStorage.removeItem(ACTIVE_PROFILE_KEY); // Remove if no profile is active
            }
        }

        // NEW: Function to populate the profile select dropdown

        function populateProfileSelectDropdown() {
            const selectElement = document.getElementById('profile-select');
            if (!selectElement) {
                console.error("Profile select dropdown element not found.");
                return;
            }
            selectElement.innerHTML = ''; // Clear existing options

            // Add the default "No Profile Selected" option
            const defaultOption = document.createElement('option');
            defaultOption.value = NO_PROFILE_SELECTED_VALUE; // Use the constant
            defaultOption.textContent = "-- No Profile Selected --";
            selectElement.appendChild(defaultOption);

            if (profileNamesList.length > 0) {
                profileNamesList.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    selectElement.appendChild(option);
                });
            }

            // Try to set the selected value to the currentProfileName
            if (currentProfileName && profileNamesList.includes(currentProfileName)) {
                selectElement.value = currentProfileName;
            } else if (profileNamesList.length > 0) {
                // If currentProfileName is not set or not valid, select the first available profile
                selectElement.value = profileNamesList[0];
                currentProfileName = profileNamesList[0]; // Update global currentProfileName
                saveActiveProfileNameToStorage(currentProfileName); // And save it as active
            } else {
                // No profiles exist, ensure "No Profile Selected" is chosen
                selectElement.value = NO_PROFILE_SELECTED_VALUE;
                currentProfileName = null; // No active profile
                saveActiveProfileNameToStorage(null);
            }
        }
        // === JS_UTILITIES END ===


        // === JS_CORE_LOGIC START ===
        // --- Core Logic Functions ---
        // NEW: Helper function to save all current working settings to the active profile
        function saveCurrentDataToActiveProfile(feedbackElementForSuccess) {
            if (!currentProfileName) {
                // ... (your existing code for no profile)
                console.log("[saveCurrentDataToActiveProfile] No currentProfileName, aborting save.");
                return false;
            }

            const profileDataToSave = {
                items: JSON.parse(JSON.stringify(currentItems)),
                markup: currentMarkup,
                pdfConfig: JSON.parse(JSON.stringify(currentPdfConfig)),
                options: JSON.parse(JSON.stringify(currentProposalOptions)),
                scopeTemplates: JSON.parse(JSON.stringify(currentScopeTemplates))
            };
            // Log the specific part related to PDF settings when testing PDF settings save
            console.log(`[saveCurrentDataToActiveProfile] For profile '${currentProfileName}', currentPdfConfig being prepared:`, JSON.stringify(currentPdfConfig));
            console.log(`[saveCurrentDataToActiveProfile] For profile '${currentProfileName}', ENTIRE profileDataToSave object:`, JSON.stringify(profileDataToSave)); // 7. Log the entire object

            try {
                localStorage.setItem(PROFILE_DATA_PREFIX + currentProfileName, JSON.stringify(profileDataToSave));
                console.log(`[saveCurrentDataToActiveProfile] Data for profile '${currentProfileName}' successfully written to localStorage.`); // 8. Confirm localStorage.setItem call
                isProfileDirty = false;

                if (btnSaveCostItems) setSaveButtonState(btnSaveCostItems, false);
                if (btnSavePdfSettings) setSaveButtonState(btnSavePdfSettings, false);
                if (btnSaveOptions) setSaveButtonState(btnSaveOptions, false);
                if (btnSaveScopeTemplates) setSaveButtonState(btnSaveScopeTemplates, false);

                if (feedbackElementForSuccess) {
                    showFeedback(feedbackElementForSuccess, 'Settings saved to profile: ' + currentProfileName, 'green');
                }
                return true;
            } catch (e) {
                console.error(`[saveCurrentDataToActiveProfile] Error saving data for profile '${currentProfileName}':`, e);
                if (feedbackElementForSuccess) {
                    showFeedback(feedbackElementForSuccess, `Error saving to profile '${currentProfileName}'.`, "red");
                }
                if (e.name === 'QuotaExceededError') {
                    alert("Error: Could not save settings. Browser storage is full. Please export your settings and clear some space if possible.");
                }
                return false;
            }
        }

        function showSection(sectionIdToShow) {
            // --- SAVE state before hiding ---
            let activeSectionId = null;
            pageSections.forEach(section => { // Find the currently active section
                if (section.classList.contains('active')) {
                    activeSectionId = section.id;
                }
            });
            if (activeSectionId === 'dashboard-section') {
                saveDashboardStateToSession(); // Save state if leaving dashboard
            }
            // --- End SAVE state ---

            // Hide all sections and deactivate buttons (existing logic)
            pageSections.forEach(section => section.classList.remove('active'));
            navButtons.forEach(button => button.classList.remove('active'));

            // Show the target section (existing logic)
            const sectionToShow = document.getElementById(sectionIdToShow);
            if (sectionToShow) sectionToShow.classList.add('active');

            let activeButton;
            switch (sectionIdToShow) {
                case 'dashboard-section':
                    activeButton = btnDashboard;
                    // Display structure first (existing logic)
                    displayDashboardItems();
                    displayDashboardOptions(); // This now applies defaults from settings
                    displayDashboardScopeDropdown();
                    // Restore saved state from session AFTER display functions run
                    restoreDashboardStateFromSession();
                    // Note: restoreDashboardStateFromSession now calls updateRunningTotals and updateConcreteCalculatorDisplay internally
                    break;
                case 'cost-items-section':
                    activeButton = btnCostItems;
                    displayCostItemSettings();
                    break;
                case 'pdf-settings-section':
                    activeButton = btnPdfSettings;
                    displayPdfSettings();
                    break;
                case 'proposal-options-section':
                    activeButton = btnProposalOptions;
                    displayProposalOptionsSettings();
                    break;
                case 'scope-templates-section':
                    activeButton = btnScopeTemplates;
                    displayScopeTemplatesSettings();
                    break;
            }
            if (activeButton) activeButton.classList.add('active');
        }

        function loadAllSettings(profileNameToLoad) {
            console.log(`Attempting to load settings for profile: ${profileNameToLoad || 'Default Fallback'}`);
            if (profileNameToLoad && profileNamesList.includes(profileNameToLoad)) {
                currentProfileName = profileNameToLoad; // Set the global active profile name
                saveActiveProfileNameToStorage(currentProfileName);

                const profileDataKey = PROFILE_DATA_PREFIX + currentProfileName;
                const storedProfileData = localStorage.getItem(profileDataKey);

                if (storedProfileData) {
                    try {
                        const data = JSON.parse(storedProfileData);
                        // Load data from the profile object into your global current... variables
                        currentItems = data.items || defaultItems.map(item => ({ pricingType: 'Fixed', formula: '', ...item }));
                        currentMarkup = (typeof data.markup === 'number') ? data.markup : defaultMarkup;
                        currentPdfConfig = {
                            ...defaultPdfConfig, // Start with defaults
                            ...(data.pdfConfig || {}), // Spread saved config over defaults
                            // Ensure new property exists, default to empty string if missing
                            companyWebsiteUrl: data.pdfConfig?.companyWebsiteUrl || ''
                        };
                        // <<< --- DEBUG LINE TO ADD/CHECK --- >>>
                        console.log("[loadAllSettings] Final currentPdfConfig state AFTER merging:", JSON.stringify(currentPdfConfig));
                        // <<< --- END DEBUG LINE --- >>>
                        currentProposalOptions = (data.options || defaultProposalOptions).map(opt => ({
                            ...opt, // Keep existing properties
                            id: opt.id || generateOptionId(),
                            description: opt.description || "",
                            // Provide defaults if the properties are missing from saved data
                            defaultSelected: opt.defaultSelected ?? false, // Default to false if missing
                            defaultShowOnQuote: opt.defaultShowOnQuote ?? true // Default to true if missing
                        }));
                        currentScopeTemplates = data.scopeTemplates || defaultScopeTemplates.map(tmpl => ({ ...tmpl, id: tmpl.id || generateScopeId() }));

                        console.log(`Settings for profile '${currentProfileName}' loaded successfully.`);
                        isProfileDirty = false; // Profile just loaded, so it's not dirty
                        setSaveButtonState(btnSaveCostItems, false); // Reset save button states
                        setSaveButtonState(btnSavePdfSettings, false);
                        setSaveButtonState(btnSaveOptions, false);
                        setSaveButtonState(btnSaveScopeTemplates, false);

                    } catch (e) {
                        console.error(`Error parsing data for profile '${currentProfileName}':`, e);
                        showFeedback(document.getElementById('profile-feedback'), `Error loading profile data for ${currentProfileName}. Using defaults.`, "red", 5000);
                        loadDefaultSettingsForCurrentProfile(); // Fallback to defaults if profile data is corrupt
                    }
                } else {
                    console.warn(`No data found for profile '${currentProfileName}'. Initializing with defaults for this profile.`);
                    showFeedback(document.getElementById('profile-feedback'), `Profile '${currentProfileName}' is empty. Initializing with defaults. Please save if you make changes.`, "orange", 7000);
                    loadDefaultSettingsForCurrentProfile(); // Load defaults if profile exists but has no data (e.g., newly created)
                }
            } else {
                // No specific profile to load, or invalid profile name provided
                // This usually means we should load the application's base defaults.
                console.log("No valid profile selected or found. Loading application defaults (not tied to a profile).");
                loadDefaultSettingsForCurrentProfile(); // This function will set currentItems etc. to app defaults
                currentProfileName = null; // Ensure no profile is marked as active
                saveActiveProfileNameToStorage(null);
                // Optionally, prompt user to create a profile if profileNamesList is empty
                if (profileNamesList.length === 0 && document.getElementById('profile-select')) {
                    document.getElementById('profile-select').value = NO_PROFILE_SELECTED_VALUE;
                    showFeedback(document.getElementById('profile-feedback'), "No profiles exist. Create a new profile to save your settings.", "orange", 0);
                }
            }

            // Refresh all UI elements based on the loaded settings (profile or default)
            // These display functions use the global currentItems, currentMarkup, etc.
            displayCostItemSettings(); // Will also call setSaveButtonState internally
            displayPdfSettings();    // Will also call setSaveButtonState internally
            displayProposalOptionsSettings(); // Will also call setSaveButtonState internally
            displayScopeTemplatesSettings();  // Will also call setSaveButtonState internally

            displayDashboardItems();
            displayDashboardOptions();
            displayDashboardScopeDropdown();
            updateRunningTotals();
            updateConcreteCalculatorDisplay();
            populateProfileSelectDropdown(); // Ensure dropdown reflects the active profile
            console.log("UI refreshed with loaded settings.");
        }

        // NEW: Helper function to load application default settings into the global current... variables
        // This is used when a profile is empty, corrupt, or no profile is active.
        function loadDefaultSettingsForCurrentProfile() {
            currentItems = defaultItems.map(item => ({ pricingType: 'Fixed', formula: '', ...item }));
            currentMarkup = defaultMarkup;
            currentPdfConfig = { ...defaultPdfConfig };
            currentProposalOptions = defaultProposalOptions.map(opt => ({ ...opt, id: opt.id || generateOptionId(), description: opt.description || "" }));
            currentScopeTemplates = defaultScopeTemplates.map(tmpl => ({ ...tmpl, id: tmpl.id || generateScopeId() }));
            console.log("Application default settings loaded into current working set.");
            isProfileDirty = true; // Mark as dirty because these defaults aren't "saved" to a profile yet
        }

        // NEW: Function to handle Profile Creation
        function handleCreateProfile() {
            if (!profileNewNameInput || !profileFeedbackSpan || !profileSelectDropdown) return;

            const newName = profileNewNameInput.value.trim();
            if (!newName) {
                showFeedback(profileFeedbackSpan, "Profile name cannot be empty.", "red", 3000);
                profileNewNameInput.focus();
                return;
            }
            if (profileNamesList.includes(newName)) {
                showFeedback(profileFeedbackSpan, `Profile '${newName}' already exists. Choose a different name.`, "red", 4000);
                profileNewNameInput.focus();
                return;
            }

            // Add to the list of profile names
            profileNamesList.push(newName);
            profileNamesList.sort(); // Keep the list sorted
            saveProfileNamesToStorage(profileNamesList);

            // currentProfileName is the one we are cloning FROM, or null if no profile was active
            const oldProfileToCloneFrom = currentProfileName;
            console.log(`Creating new profile '${newName}', cloning from '${oldProfileToCloneFrom || 'Defaults'}'`);

            // Switch currentProfileName to the new profile
            currentProfileName = newName;
            saveActiveProfileNameToStorage(currentProfileName);

            // Save the current working settings (which are either from the cloned profile or app defaults)
            // under the NEW profile name.
            // The currentItems, currentMarkup, etc. are already loaded from the previous profile or defaults.
            const newProfileData = {
                items: JSON.parse(JSON.stringify(currentItems)), // Deep clone
                markup: currentMarkup,
                pdfConfig: JSON.parse(JSON.stringify(currentPdfConfig)), // Deep clone
                options: JSON.parse(JSON.stringify(currentProposalOptions)), // Deep clone
                scopeTemplates: JSON.parse(JSON.stringify(currentScopeTemplates)) // Deep clone
            };
            try {
                localStorage.setItem(PROFILE_DATA_PREFIX + currentProfileName, JSON.stringify(newProfileData));
                console.log(`Data for new profile '${currentProfileName}' saved.`);
                isProfileDirty = false; // Freshly created and saved
            } catch (e) {
                console.error(`Error saving data for new profile '${currentProfileName}':`, e);
                showFeedback(profileFeedbackSpan, `Error saving new profile '${currentProfileName}'.`, "red");
                // If saving fails, we should probably roll back adding the name to the list, but that's more complex for now.
                // For now, the name might be in the list but the data save failed.
                currentProfileName = oldProfileToCloneFrom; // Revert active profile name
                saveActiveProfileNameToStorage(currentProfileName);
                profileNamesList = profileNamesList.filter(name => name !== newName); // Attempt to remove from list
                saveProfileNamesToStorage(profileNamesList);
                populateProfileSelectDropdown();
                return;
            }


            profileNewNameInput.value = ''; // Clear the input
            populateProfileSelectDropdown(); // Refresh dropdown, new profile will be selected
            loadAllSettings(currentProfileName); // Reload all settings for the new profile to ensure UI consistency

            showFeedback(profileFeedbackSpan, `Profile '${currentProfileName}' created successfully.`, "green");
        }

        // NEW: Function to handle Profile Renaming
        function handleRenameProfile() {
            if (!profileSelectDropdown || !profileFeedbackSpan) return;

            const selectedProfileToRename = profileSelectDropdown.value;
            if (!selectedProfileToRename || selectedProfileToRename === NO_PROFILE_SELECTED_VALUE) {
                showFeedback(profileFeedbackSpan, "No profile selected to rename.", "orange", 3000);
                return;
            }

            const newName = prompt(`Enter the new name for profile '${selectedProfileToRename}':`, selectedProfileToRename);
            if (newName === null) { // User cancelled prompt
                return;
            }
            const trimmedNewName = newName.trim();
            if (!trimmedNewName) {
                showFeedback(profileFeedbackSpan, "New profile name cannot be empty.", "red", 3000);
                return;
            }
            if (trimmedNewName === selectedProfileToRename) {
                showFeedback(profileFeedbackSpan, "New name is the same as the current name.", "orange", 3000);
                return;
            }
            if (profileNamesList.includes(trimmedNewName)) {
                showFeedback(profileFeedbackSpan, `Profile name '${trimmedNewName}' already exists. Choose a different name.`, "red", 4000);
                return;
            }

            // Get the data from the old profile key
            const oldProfileDataKey = PROFILE_DATA_PREFIX + selectedProfileToRename;
            const profileData = localStorage.getItem(oldProfileDataKey);

            if (profileData) {
                // Save data under the new profile key
                const newProfileDataKey = PROFILE_DATA_PREFIX + trimmedNewName;
                localStorage.setItem(newProfileDataKey, profileData);
                // Remove the old profile data
                localStorage.removeItem(oldProfileDataKey);
            } else {
                console.warn(`No data found for profile '${selectedProfileToRename}' during rename. Only name will be updated in list.`);
                // If data didn't exist, we still proceed to rename it in the list if the user confirms
                // This handles cases where a profile name might exist without corresponding data due to a previous error.
            }


            // Update the name in the profileNamesList
            profileNamesList = profileNamesList.map(name => (name === selectedProfileToRename ? trimmedNewName : name));
            profileNamesList.sort();
            saveProfileNamesToStorage(profileNamesList);

            // Update active profile name if the renamed profile was active
            if (currentProfileName === selectedProfileToRename) {
                currentProfileName = trimmedNewName;
                saveActiveProfileNameToStorage(currentProfileName);
            }

            populateProfileSelectDropdown(); // Refresh dropdown with the new name
            // Ensure the renamed profile (which is likely the current one) is selected
            if (profileSelectDropdown.value !== currentProfileName && currentProfileName) {
                profileSelectDropdown.value = currentProfileName;
            }
            showFeedback(profileFeedbackSpan, `Profile '${selectedProfileToRename}' renamed to '${trimmedNewName}'.`, "green");
            isProfileDirty = false; // Assume rename implies a "clean" state for the now-renamed profile.
        }

        // NEW: Function to handle Profile Deletion
        function handleDeleteProfile() {
            if (!profileSelectDropdown || !profileFeedbackSpan) return;

            const profileToDelete = profileSelectDropdown.value;
            if (!profileToDelete || profileToDelete === NO_PROFILE_SELECTED_VALUE) {
                showFeedback(profileFeedbackSpan, "No profile selected to delete.", "orange", 3000);
                return;
            }

            if (confirm(`Are you sure you want to delete profile '${profileToDelete}'? This cannot be undone.`)) {
                // Remove data from localStorage
                localStorage.removeItem(PROFILE_DATA_PREFIX + profileToDelete);

                // Remove name from profileNamesList
                profileNamesList = profileNamesList.filter(name => name !== profileToDelete);
                saveProfileNamesToStorage(profileNamesList);

                showFeedback(profileFeedbackSpan, `Profile '${profileToDelete}' deleted.`, "green");

                // If the deleted profile was the active one, we need to switch
                if (currentProfileName === profileToDelete) {
                    currentProfileName = null; // Reset active profile
                    if (profileNamesList.length > 0) {
                        currentProfileName = profileNamesList[0]; // Select the first available one
                    }
                    saveActiveProfileNameToStorage(currentProfileName);
                    loadAllSettings(currentProfileName); // Load the new active profile (or defaults if none left)
                } else {
                    // If a different profile was deleted, just refresh the dropdown
                    populateProfileSelectDropdown();
                }
                // If no profiles are left, loadAllSettings(null) will handle showing defaults
                if (profileNamesList.length === 0) {
                    loadAllSettings(null);
                }
            }
        }

        function handleProfileSelectChange(event) {
            // --- Start: Check for elements and declare newSelectedName ---
            if (!profileFeedbackSpan || !profileSelectDropdown) {
                console.error("[handleProfileSelectChange] Critical elements (profileFeedbackSpan or profileSelectDropdown) missing.");
                return;
            }
            // *** THIS LINE DECLARES the variable based on the dropdown change ***
            const newSelectedName = event.target.value;
            // --- End: Check for elements ---

            // Check if the selected profile is the same as the current one
            if (newSelectedName === currentProfileName) {
                console.log("[handleProfileSelectChange] newSelectedName is the same as currentProfileName. No action taken.");
                return;
            }

            // Check for unsaved changes before switching
            if (isProfileDirty && currentProfileName && currentProfileName !== NO_PROFILE_SELECTED_VALUE) {
                if (confirm(`You have unsaved changes in profile '${currentProfileName}'. Save them before switching? \n\n - Click 'OK' to SAVE and switch. \n - Click 'Cancel' to NOT SAVE and switch.`)) {
                    // User clicked 'OK' - wants to SAVE and switch
                    let saveSuccessful = false;
                    let activeSaveFunctionName = "Unknown"; // For logging

                    // Determine active section and call its save function
                    if (costItemsSection && costItemsSection.classList.contains('active')) {
                        activeSaveFunctionName = "saveCostItemsAndMarkup";
                        console.log("[handleProfileSelectChange] Determined: Cost Items. Calling " + activeSaveFunctionName);
                        saveSuccessful = saveCostItemsAndMarkup();
                    } else if (pdfSettingsSection && pdfSettingsSection.classList.contains('active')) {
                        activeSaveFunctionName = "savePdfSettings";
                        console.log("[handleProfileSelectChange] Determined: PDF Settings. Calling " + activeSaveFunctionName);
                        saveSuccessful = savePdfSettings();
                    } else if (proposalOptionsSection && proposalOptionsSection.classList.contains('active')) {
                        activeSaveFunctionName = "saveProposalOptions";
                        console.log("[handleProfileSelectChange] Determined: Proposal Options. Calling " + activeSaveFunctionName);
                        saveSuccessful = saveProposalOptions();
                    } else if (scopeTemplatesSection && scopeTemplatesSection.classList.contains('active')) {
                        activeSaveFunctionName = "saveScopeTemplates";
                        console.log("[handleProfileSelectChange] Determined: Scope Templates. Calling " + activeSaveFunctionName);
                        saveSuccessful = saveScopeTemplates();
                    } else {
                        // Fallback if no specific settings section is active (e.g., user was on Dashboard)
                        activeSaveFunctionName = "saveCurrentDataToActiveProfile (fallback from handleProfileSelectChange)";
                        console.log("[handleProfileSelectChange] No specific settings section active or detected. Using fallback path to call: " + activeSaveFunctionName);
                        // Note: The saveCurrentDataToActiveProfile saves ALL settings parts (items, markup, pdf, options, scopes)
                        // We pass profileFeedbackSpan because there's no section-specific feedback area for this fallback.
                        saveSuccessful = saveCurrentDataToActiveProfile(profileFeedbackSpan);
                    }
                    console.log(`[handleProfileSelectChange] Attempted save via ${activeSaveFunctionName} during profile switch. Result (saveSuccessful): ${saveSuccessful}`);

                    if (!saveSuccessful) {
                        // If saving failed (e.g., validation error), abort the switch
                        showFeedback(profileFeedbackSpan, `Could not save changes to '${currentProfileName}'. Switch aborted. Please fix errors or save manually, then try again.`, "red", 7000);
                        profileSelectDropdown.value = currentProfileName; // Revert dropdown to the current (unsaved) profile
                        return; // Abort the switch
                    }
                    // If save was successful, fall through to clear session state and load new profile
                    console.log(`[handleProfileSelectChange] Changes to '${currentProfileName}' considered saved. Proceeding to switch to '${newSelectedName}'.`);
                } else {
                    // User clicked 'Cancel' on the confirm dialog - DO NOT SAVE, but DO SWITCH.
                    console.log(`[handleProfileSelectChange] User chose not to save changes to '${currentProfileName}'. Proceeding to switch to '${newSelectedName}'.`);
                    // Fall through to clear session state and load new profile
                }
            } // End of isProfileDirty check

            // --- Clear session state BEFORE loading new profile ---
            console.log("[handleProfileSelectChange] Clearing dashboard session state before profile switch.");
            clearDashboardStateFromSession();
            // ---

            // At this point, proceed to load the newly selected profile.
            console.log(`[handleProfileSelectChange] Proceeding to load settings for: ${newSelectedName || 'Defaults (no profile)'}`);
            if (newSelectedName === NO_PROFILE_SELECTED_VALUE) {
                // User selected "-- No Profile Selected --"
                currentProfileName = null;
                saveActiveProfileNameToStorage(null);
                loadAllSettings(null); // Load default application settings
                showFeedback(profileFeedbackSpan, "Switched to default settings. Create or select a profile to save changes.", "orange", 5000);
            } else {
                // User selected a specific profile name
                loadAllSettings(newSelectedName); // This function will set currentProfileName and save it as active
                // Provide feedback based on whether loading was successful (loadAllSettings updates currentProfileName)
                if (currentProfileName === newSelectedName) {
                    showFeedback(profileFeedbackSpan, `Switched to profile '${newSelectedName}'.`, "green");
                }
                // If loadAllSettings failed, it might have loaded defaults or another profile; feedback within loadAllSettings handles errors.
            }

            // Ensure the dropdown accurately reflects the final active profile state
            // This handles cases where loadAllSettings might have failed or defaulted.
            if (currentProfileName && profileSelectDropdown.value !== currentProfileName) {
                profileSelectDropdown.value = currentProfileName;
            } else if (!currentProfileName && profileSelectDropdown.value !== NO_PROFILE_SELECTED_VALUE) {
                profileSelectDropdown.value = NO_PROFILE_SELECTED_VALUE;
            }
        } // --- End of handleProfileSelectChange function ---


        function displayCostItemSettings() {
            if (!markupInput || !settingsItemsBody || !costItemsSection) {
                console.error("Missing cost item settings elements.");
                return;
            }
            clearValidationErrors(costItemsSection);
            markupInput.value = currentMarkup;
            settingsItemsBody.innerHTML = ''; // Clear previous rows
            if (!Array.isArray(currentItems) || currentItems.length === 0) {
                const row = settingsItemsBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 6;
                cell.textContent = "No items defined. Add items below.";
                cell.style.textAlign = 'center';
                cell.style.fontStyle = 'italic';
                return;
            }

            currentItems.forEach((item, index) => {
                const row = settingsItemsBody.insertRow();
                row.setAttribute('data-index', index);

                // Name
                const cellName = row.insertCell();
                const inputName = document.createElement('input');
                inputName.type = 'text';
                inputName.className = 'item-name';
                inputName.value = item.name || '';
                cellName.appendChild(inputName);

                // Type
                const cellType = row.insertCell();
                const selectType = document.createElement('select');
                selectType.className = 'item-pricing-type';
                ['Fixed', 'Formula'].forEach(type => {
                    const opt = document.createElement('option');
                    opt.value = type;
                    opt.textContent = type;
                    if ((item.pricingType || 'Fixed') === type) opt.selected = true;
                    selectType.appendChild(opt);
                });
                cellType.appendChild(selectType);

                // Unit
                const cellUnit = row.insertCell();
                const inputUnit = document.createElement('input');
                inputUnit.type = 'text';
                inputUnit.className = 'item-unit';
                inputUnit.value = item.unit || '';
                cellUnit.appendChild(inputUnit);

                // Value (Cost/Formula)
                const cellVal = row.insertCell();
                const inputCost = document.createElement('input');
                inputCost.type = 'number';
                inputCost.className = 'item-cost';
                inputCost.value = parseFloat(item.cost || 0).toFixed(2);
                inputCost.min = '0';
                inputCost.step = '0.01';
                inputCost.style.display = (item.pricingType !== 'Formula') ? 'block' : 'none';
                cellVal.appendChild(inputCost);

                const inputFormula = document.createElement('input');
                inputFormula.type = 'text';
                inputFormula.className = 'item-formula';
                inputFormula.value = item.formula || '';
                inputFormula.placeholder = 'e.g., quantity * 5';
                inputFormula.title = "Use vars: quantity, jobArea, jobThickness";
                inputFormula.style.display = (item.pricingType === 'Formula') ? 'block' : 'none';
                cellVal.appendChild(inputFormula);

                // --- FORMULA GENERATOR BUTTON (SYMBOL) ---
                const generateFormulaButton = document.createElement('button');
                generateFormulaButton.innerHTML = 'f(x)';
                generateFormulaButton.title = 'Generate Formula';
                generateFormulaButton.className = 'generate-formula-button';
                generateFormulaButton.id = `btn-generate-formula-${index}`;
                generateFormulaButton.addEventListener('click', () => openFormulaGeneratorModal(index));
                cellVal.appendChild(generateFormulaButton);
                generateFormulaButton.style.fontSize = '0.8em';
                generateFormulaButton.style.padding = '2px 5px';
                // --- END FORMULA GENERATOR BUTTON ---

                // Description
                const cellDesc = row.insertCell();
                const inputDesc = document.createElement('textarea');
                inputDesc.className = 'item-description';
                inputDesc.value = item.description || '';
                inputDesc.rows = 1;
                cellDesc.appendChild(inputDesc);

                // Action Cell
                const cellAction = row.insertCell();
                cellAction.style.textAlign = 'center';
                cellAction.style.whiteSpace = 'nowrap';

                const btnUp = document.createElement('button');
                btnUp.innerHTML = '&uarr;';
                btnUp.title = 'Move Up';
                btnUp.className = 'move-button';
                btnUp.disabled = (index === 0);
                btnUp.onclick = (e) => {
                    e.preventDefault();
                    moveCostItem(index, -1);
                };
                cellAction.appendChild(btnUp);

                const btnDown = document.createElement('button');
                btnDown.innerHTML = '&darr;';
                btnDown.title = 'Move Down';
                btnDown.className = 'move-button';
                btnDown.disabled = (index === currentItems.length - 1);
                btnDown.onclick = (e) => {
                    e.preventDefault();
                    moveCostItem(index, 1);
                };
                cellAction.appendChild(btnDown);

                const btnDel = document.createElement('button');
                btnDel.textContent = 'Del';
                btnDel.title = 'Delete Item';
                btnDel.className = 'delete-button';
                btnDel.style.marginLeft = '4px';
                btnDel.onclick = (e) => {
                    e.preventDefault();
                    deleteItem(index);
                };
                cellAction.appendChild(btnDel);

                // Event Listener for Type change
                selectType.onchange = () => {
                    inputCost.style.display = (selectType.value === 'Fixed') ? 'block' : 'none';
                    inputFormula.style.display = (selectType.value === 'Formula') ? 'block' : 'none';
                    setSaveButtonState(btnSaveCostItems, true);
                };
            });
            setSaveButtonState(btnSaveCostItems, false); // Reset save state on display
        }

        function displayPdfSettings() {
            // --- ADDED/CONFIRMED LINES START ---
            // Ensure elements exist before attempting to set their values
            // These lines ensure the main text fields are populated from loaded profile data
            if (pdfCompanyNameInput) pdfCompanyNameInput.value = currentPdfConfig.companyName || '';
            if (pdfCompanyAddressInput) pdfCompanyAddressInput.value = currentPdfConfig.companyAddress || '';
            if (pdfCompanyContactInput) pdfCompanyContactInput.value = currentPdfConfig.companyContact || '';
            if (pdfDefaultNotesInput) pdfDefaultNotesInput.value = currentPdfConfig.defaultNotes || '';
            // --- ADDED/CONFIRMED LINES END ---

            // --- Existing lines for other fields ---
            if (pdfProposalLineColorInput) {
                pdfProposalLineColorInput.value = currentPdfConfig.proposalLineColor || DEFAULT_PROPOSAL_LINE_COLOR;
            }

            const websiteInput = document.getElementById('pdf-company-website');
            if (websiteInput) {
                websiteInput.value = currentPdfConfig.companyWebsiteUrl || '';
            }

            // Logo preview logic 
            if (currentPdfConfig.logoDataUrl && typeof currentPdfConfig.logoDataUrl === 'string' && currentPdfConfig.logoDataUrl.startsWith('data:image')) {
                if (logoPreview) {
                    logoPreview.src = currentPdfConfig.logoDataUrl;
                    logoPreview.style.display = 'inline-block';
                }
                if (logoStatus) {
                    logoStatus.textContent = 'Logo loaded from profile.';
                    logoStatus.style.color = '#888';
                }
            } else {
                // Handle case where no logo is saved
                if (logoPreview) {
                    logoPreview.src = "";
                    logoPreview.style.display = 'none';
                }
                if (logoStatus) {
                    logoStatus.textContent = 'No logo saved in profile.';
                }
            }

            // Clear file input selection display (important!)
            if (pdfLogoFileInput) {
                pdfLogoFileInput.value = null;
            }

            // Reset save button state as settings were just loaded/displayed
            setSaveButtonState(btnSavePdfSettings, false);
        }

        function displayProposalOptionsSettings() {
            if (!proposalOptionsBody || !proposalOptionsSection) { console.error("Proposal options elements missing."); return; }
            clearValidationErrors(proposalOptionsSection);
            proposalOptionsBody.innerHTML = ''; // Clear previous rows

            // --- Add New Headers ---
            const tableHead = proposalOptionsBody.closest('table').querySelector('thead tr');
            if (tableHead && tableHead.cells.length === 5) { // Check to avoid adding headers multiple times
                const thSelected = document.createElement('th');
                thSelected.textContent = 'Default Selected?';
                thSelected.style.width = '10%'; // Adjust width as needed
                thSelected.style.textAlign = 'center';
                tableHead.insertBefore(thSelected, tableHead.cells[4]); // Insert before Action

                const thShow = document.createElement('th');
                thShow.textContent = 'Default Show?';
                thShow.style.width = '10%'; // Adjust width as needed
                thShow.style.textAlign = 'center';
                tableHead.insertBefore(thShow, tableHead.cells[5]); // Insert before Action

                // Adjust Action column width if needed
                tableHead.cells[6].style.width = '10%'; // Original Action column is now cell 6
            }
            // --- End Add New Headers ---


            if (!Array.isArray(currentProposalOptions) || currentProposalOptions.length === 0) {
                const row = proposalOptionsBody.insertRow(); const cell = row.insertCell();
                cell.colSpan = 7; // <<<< ADJUST COLSPAN TO 7
                cell.textContent = "No options defined. Add options below."; cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; return;
            }

            currentProposalOptions.forEach((option, index) => {
                const optionId = option?.id; if (!optionId) { console.warn("Skipping option without ID:", option); return; }
                const row = proposalOptionsBody.insertRow(); row.setAttribute('data-id', optionId); row.setAttribute('data-index', index);
                // Name
                const cellName = row.insertCell(); const inputName = document.createElement('input'); inputName.type = 'text'; inputName.className = 'option-name'; inputName.value = option.name || ''; cellName.appendChild(inputName);
                // Description
                const cellDesc = row.insertCell(); const inputDesc = document.createElement('textarea'); inputDesc.className = 'option-description'; inputDesc.value = option.description || ''; inputDesc.rows = 1; cellDesc.appendChild(inputDesc);
                // Type
                const cellType = row.insertCell(); const selectType = document.createElement('select'); selectType.className = 'option-type'; const types = ["Fixed", "Percent"]; types.forEach(type => { const typeOption = document.createElement('option'); typeOption.value = type; typeOption.textContent = type; if (option.type === type) { typeOption.selected = true; } selectType.appendChild(typeOption); }); cellType.appendChild(selectType);
                // Value
                const cellValue = row.insertCell(); const inputValue = document.createElement('input'); inputValue.type = 'number'; inputValue.className = 'option-value'; inputValue.step = 'any'; inputValue.value = option.value || 0; cellValue.appendChild(inputValue);

                // --- Add Checkbox Cells ---
                // Default Selected Checkbox
                const cellDefaultSelected = row.insertCell(); cellDefaultSelected.style.textAlign = 'center';
                const checkSelected = document.createElement('input'); checkSelected.type = 'checkbox'; checkSelected.className = 'option-default-selected-checkbox'; checkSelected.checked = option.defaultSelected ?? false; cellDefaultSelected.appendChild(checkSelected);

                // Default Show on Quote Checkbox
                const cellDefaultShow = row.insertCell(); cellDefaultShow.style.textAlign = 'center';
                const checkShow = document.createElement('input'); checkShow.type = 'checkbox'; checkShow.className = 'option-default-show-checkbox'; checkShow.checked = option.defaultShowOnQuote ?? true; cellDefaultShow.appendChild(checkShow);
                // --- End Add Checkbox Cells ---


                // Action Cell
                const cellAction = row.insertCell(); cellAction.style.textAlign = 'center'; cellAction.style.whiteSpace = 'nowrap';
                // ... (keep existing Up/Down/Delete buttons) ...
                const btnUp = document.createElement('button'); btnUp.innerHTML = '&uarr;'; btnUp.title = 'Move Up'; btnUp.className = 'move-button'; btnUp.disabled = (index === 0); btnUp.onclick = (e) => { e.preventDefault(); moveProposalOption(index, -1); }; cellAction.appendChild(btnUp);
                const btnDown = document.createElement('button'); btnDown.innerHTML = '&darr;'; btnDown.title = 'Move Down'; btnDown.className = 'move-button'; btnDown.disabled = (index === currentProposalOptions.length - 1); btnDown.onclick = (e) => { e.preventDefault(); moveProposalOption(index, 1); }; cellAction.appendChild(btnDown);
                const btnDel = document.createElement('button'); btnDel.textContent = 'Del'; btnDel.title = 'Delete Option'; btnDel.className = 'delete-button'; btnDel.style.padding = '2px 5px'; btnDel.style.fontSize = '0.85em'; btnDel.onclick = (e) => { e.preventDefault(); deleteProposalOption(optionId); }; cellAction.appendChild(btnDel);
            });
            setSaveButtonState(btnSaveOptions, false); // Reset save state on display
        }

        function displayScopeTemplatesSettings() {
            if (!scopeTemplatesBody || !scopeTemplatesSection) { console.error("Scope templates elements missing."); return; }
            clearValidationErrors(scopeTemplatesSection);
            scopeTemplatesBody.innerHTML = ''; // Clear previous rows
            if (!Array.isArray(currentScopeTemplates) || currentScopeTemplates.length === 0) {
                const row = scopeTemplatesBody.insertRow(); const cell = row.insertCell(); cell.colSpan = 3; cell.textContent = "No scope templates defined. Add templates below."; cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; return;
            }
            currentScopeTemplates.forEach((template) => {
                const templateId = template?.id; if (!templateId) { console.warn("Skipping scope template without ID:", template); return; }
                const row = scopeTemplatesBody.insertRow(); row.setAttribute('data-id', templateId);
                // Name
                const cellName = row.insertCell(); const inputName = document.createElement('input'); inputName.type = 'text'; inputName.className = 'scope-name'; inputName.value = template.name || ''; cellName.appendChild(inputName);
                // Text
                const cellText = row.insertCell(); const inputText = document.createElement('textarea'); inputText.className = 'scope-text'; inputText.value = template.text || ''; inputText.rows = 3; cellText.appendChild(inputText);
                // Action
                const cellAction = row.insertCell(); cellAction.style.textAlign = 'center'; const deleteButton = document.createElement('button'); deleteButton.textContent = 'Delete'; deleteButton.className = 'delete-button'; deleteButton.onclick = (event) => { event.preventDefault(); deleteScopeTemplate(templateId); }; cellAction.appendChild(deleteButton);
            });
            setSaveButtonState(btnSaveScopeTemplates, false); // Reset save state
        }

        function addItem() {
            if (!Array.isArray(currentItems)) { currentItems = []; }
            currentItems.push({ name: "", pricingType: "Fixed", unit: "", cost: 0.00, formula: "", description: "" });
            displayCostItemSettings(); // Refresh display
            const tableBody = document.getElementById('settings-items-body'); if (tableBody) tableBody.parentElement.scrollTop = tableBody.parentElement.scrollHeight;
            setSaveButtonState(btnSaveCostItems, true); // Mark changes for the button
            if (currentProfileName) { // Ensure a profile is active
                isProfileDirty = true; // Explicitly mark the profile as dirty
            }
        }

        function deleteItem(indexToDelete) {
            if (!Array.isArray(currentItems) || indexToDelete < 0 || indexToDelete >= currentItems.length) { console.error("Invalid index for deletion:", indexToDelete); return; }
            const item = currentItems[indexToDelete];
            const itemName = item?.name;
            if (confirm(`Are you sure you want to delete the item "${itemName || 'this new item'}"?`)) {
                currentItems.splice(indexToDelete, 1); // Remove from the array
                displayCostItemSettings(); // Re-render the table
                showFeedback(costItemsFeedback, "Item removed. Save changes to make permanent.", "orange");
                setSaveButtonState(btnSaveCostItems, true); // Mark changes
            }
        }

        function moveCostItem(index, direction) {
            if (!Array.isArray(currentItems) || currentItems.length < 2) return;
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= currentItems.length) return; // Boundary check
            [currentItems[index], currentItems[newIndex]] = [currentItems[newIndex], currentItems[index]]; // Swap
            displayCostItemSettings(); // Re-render
            showFeedback(costItemsFeedback, "Order changed. Save changes to make permanent.", "orange");
            setSaveButtonState(btnSaveCostItems, true);
        }


        function addProposalOption() {
            if (!Array.isArray(currentProposalOptions)) { currentProposalOptions = []; }
            const newOption = { id: generateOptionId(), name: "", description: "", type: "Fixed", value: 0 };
            currentProposalOptions.push(newOption);
            displayProposalOptionsSettings();
            const tableBody = document.getElementById('proposal-options-body'); if (tableBody) tableBody.parentElement.scrollTop = tableBody.parentElement.scrollHeight;
            setSaveButtonState(btnSaveOptions, true);
        }

        function deleteProposalOption(idToDelete) {
            if (!Array.isArray(currentProposalOptions)) { console.error("Cannot delete option, currentProposalOptions is not an array."); return; }
            const optionIndex = currentProposalOptions.findIndex(opt => opt.id === idToDelete); if (optionIndex === -1) { console.error("Option not found:", idToDelete); return; }
            const optionName = currentProposalOptions[optionIndex]?.name;
            if (confirm(`Are you sure you want to delete the option/adjustment "${optionName || 'this new item'}"?`)) {
                currentProposalOptions.splice(optionIndex, 1);
                displayProposalOptionsSettings(); // Refresh settings table
                displayDashboardOptions(); // Refresh dashboard display
                updateRunningTotals(); // Recalculate totals
                showFeedback(optionsFeedback, "Item removed. Save changes to make permanent.", "orange");
                setSaveButtonState(btnSaveOptions, true);
            }
        }

        function moveProposalOption(index, direction) {
            if (!Array.isArray(currentProposalOptions) || currentProposalOptions.length < 2) return;
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= currentProposalOptions.length) { console.warn("Cannot move option outside bounds."); return; }
            [currentProposalOptions[index], currentProposalOptions[newIndex]] = [currentProposalOptions[newIndex], currentProposalOptions[index]]; // Swap
            displayProposalOptionsSettings(); // Re-render settings table
            showFeedback(optionsFeedback, "Order changed. Save options to make permanent.", "orange");
            setSaveButtonState(btnSaveOptions, true);
        }

        function addScopeTemplate() {
            if (!Array.isArray(currentScopeTemplates)) { currentScopeTemplates = []; }
            const newTemplate = { id: generateScopeId(), name: "", text: "" };
            currentScopeTemplates.push(newTemplate);
            displayScopeTemplatesSettings();
            const tableBody = document.getElementById('scope-templates-body'); if (tableBody) tableBody.parentElement.scrollTop = tableBody.parentElement.scrollHeight;
            setSaveButtonState(btnSaveScopeTemplates, true);
        }

        function deleteScopeTemplate(idToDelete) {
            if (!Array.isArray(currentScopeTemplates)) { console.error("Cannot delete scope, currentScopeTemplates is not an array."); return; }
            const templateIndex = currentScopeTemplates.findIndex(tmpl => tmpl.id === idToDelete); if (templateIndex === -1) { console.error("Scope template not found:", idToDelete); return; }
            const templateName = currentScopeTemplates[templateIndex]?.name;
            if (confirm(`Are you sure you want to delete the scope template "${templateName || 'this new template'}"?`)) {
                currentScopeTemplates.splice(templateIndex, 1);
                displayScopeTemplatesSettings(); // Refresh settings table
                displayDashboardScopeDropdown(); // Update dropdown on dashboard
                showFeedback(scopeTemplatesFeedback, "Template removed. Save changes to make permanent.", "orange");
                setSaveButtonState(btnSaveScopeTemplates, true);
            }
        }

        // THIS IS THE CORRECTED/UPDATED saveCostItemsAndMarkup FUNCTION
        function saveCostItemsAndMarkup() {
            console.log("[saveCostItemsAndMarkup] Called."); // Keep this for now
            if (!markupInput || !settingsItemsBody || !costItemsSection || !costItemsFeedback) {
                console.error("[saveCostItemsAndMarkup] Pre-condition failed: Missing elements.");
                return false; // Ensure boolean return
            }
            if (!currentProfileName) {
                showFeedback(costItemsFeedback, "No active profile. Please create or select a profile first.", "red", 5000);
                if (profileNewNameInput) profileNewNameInput.focus();
                console.log("[saveCostItemsAndMarkup] No active profile.");
                return false; // Ensure boolean return
            }

            clearValidationErrors(costItemsSection);
            let isValid = true;
            let firstErrorElement = null;

            const newMarkup = parseFloat(markupInput.value);
            if (isNaN(newMarkup) || newMarkup < 0) {
                markupInput.classList.add(INVALID_CLASS);
                if (markupValidationError) {
                    markupValidationError.textContent = "Markup must be a non-negative number.";
                    markupValidationError.style.display = 'inline';
                }
                isValid = false;
                if (!firstErrorElement) firstErrorElement = markupInput;
            }

            const updatedItems = [];
            const rows = settingsItemsBody.querySelectorAll('tr');

            if (rows.length === 1 && rows[0].cells.length === 1 && rows[0].cells[0].colSpan === 6 && rows[0].cells[0].textContent.startsWith("No items defined")) {
                // Empty table is valid, currentItems will become an empty array later
            } else {
                rows.forEach((row, rowIndex) => {
                    if (!isValid) return; // Optimization: if already invalid, skip further row processing

                    const nameInput = row.querySelector('.item-name');
                    const typeSelect = row.querySelector('.item-pricing-type');
                    const unitInput = row.querySelector('.item-unit');
                    const costInput = row.querySelector('.item-cost');
                    const formulaInput = row.querySelector('.item-formula');
                    const descInput = row.querySelector('.item-description');

                    if (!nameInput || !typeSelect || !unitInput || !costInput || !formulaInput || !descInput) {
                        console.error(`[saveCostItemsAndMarkup] Missing fields in Cost Item Row ${rowIndex + 1}.`);
                        showFeedback(costItemsFeedback, `Error: Fields missing in Row ${rowIndex + 1}. Save aborted.`, "red", 0);
                        isValid = false; // Set main isValid flag
                        if (!firstErrorElement) firstErrorElement = nameInput || row; // Mark an element for focus
                        return; // Exit this iteration of forEach
                    }

                    const name = nameInput.value.trim();
                    const type = typeSelect.value;
                    const cost = parseFloat(costInput.value);
                    const formula = formulaInput.value.trim();
                    const unit = unitInput.value.trim();
                    const description = descInput.value.trim();
                    let rowIsValid = true;

                    // For existing items, name is required. For new items, it was saving blank ones fine before.
                    // Let's assume name is required if it's not the placeholder "No items defined" row.
                    if (!name) {
                        nameInput.classList.add(INVALID_CLASS);
                        rowIsValid = false;
                        if (!firstErrorElement) firstErrorElement = nameInput;
                    }
                    if (type === 'Fixed' && (isNaN(cost) || cost < 0)) {
                        costInput.classList.add(INVALID_CLASS);
                        rowIsValid = false;
                        if (!firstErrorElement) firstErrorElement = costInput;
                    }
                    if (type === 'Formula' && !formula) {
                        formulaInput.classList.add(INVALID_CLASS);
                        rowIsValid = false;
                        if (!firstErrorElement) firstErrorElement = formulaInput;
                    }

                    if (!rowIsValid) {
                        isValid = false; // If any row is invalid, the whole save is invalid
                    } else {
                        // --- Save Formula Generator State ---
                        let formulaGeneratorState = null;
                        if (type === 'Formula' && formula) {
                            formulaGeneratorState = {
                                minTotalCost: parseFloat(document.getElementById('modal-minTotalCost').value),
                                flatCost: parseFloat(document.getElementById('modal-flatCost').value),
                                brackets: []
                            };

                            const bracketRows = document.querySelectorAll('#modal-brackets .bracket-row');
                            bracketRows.forEach(bracketRow => {
                                formulaGeneratorState.brackets.push({
                                    minSf: parseFloat(bracketRow.querySelector('.min-bracket-sf').value) || 0,
                                    maxSf: parseFloat(bracketRow.querySelector('.max-bracket-sf').value) || null,
                                    costType: bracketRow.querySelector('.cost-type').value,
                                    costValue: parseFloat(bracketRow.querySelector(bracketRow.querySelector('.cost-type').value === 'costPerSf' ? '.cost-per-sf-input' : '.fixed-cost-input').value)
                                });
                            });
                        }
                        // --- End Save Formula Generator State ---
                        updatedItems.push({ name, pricingType: type, unit, cost: (type === 'Fixed') ? cost : 0, formula: (type === 'Formula') ? formula : "", description, formulaGeneratorState });
                    }
                });
            }

            if (!isValid) {
                console.warn("[saveCostItemsAndMarkup] Validation failed. Cost items/markup not saved.");
                showFeedback(costItemsFeedback, "Validation error(s). Please fix highlighted fields and save again.", "red", 0);
                if (firstErrorElement) {
                    firstErrorElement.focus();
                }
                return false; // Ensure boolean return
            }

            currentItems = updatedItems;
            currentMarkup = newMarkup;

            if (saveCurrentDataToActiveProfile(costItemsFeedback)) {
                displayCostItemSettings(); // Refresh display from updated globals
                displayDashboardItems();    // Refresh dashboard items display
                updateRunningTotals();      // Update totals
                console.log("[saveCostItemsAndMarkup] saveCurrentDataToActiveProfile reported SUCCESS.");
                return true; // Ensure boolean return for success
            } else {
                console.log("[saveCostItemsAndMarkup] saveCurrentDataToActiveProfile reported FAILURE.");
                return false; // Ensure boolean return for failure
            }
        }

        function savePdfSettings() {
            console.log("[savePdfSettings] Function called."); // Log 1
            const feedbackEl = pdfSettingsFeedback; // Ensure feedbackEl is defined
            if (!pdfCompanyNameInput || !pdfCompanyAddressInput || !pdfCompanyContactInput || !pdfDefaultNotesInput || !pdfProposalLineColorInput || !pdfLogoFileInput || !feedbackEl) { // Added checks
                console.error("[savePdfSettings] Pre-condition failed: Missing one or more required PDF settings elements.");
                return false;
            }
            if (!currentProfileName) {
                showFeedback(feedbackEl, "No active profile selected. Cannot save PDF settings.", "red", 5000);
                if (profileNewNameInput) profileNewNameInput.focus();
                console.log("[savePdfSettings] No active profile.");
                return false;
            }
            clearValidationErrors(pdfSettingsSection);

            // Read all values from DOM
            const domCompanyName = pdfCompanyNameInput.value.trim();
            const domCompanyAddress = pdfCompanyAddressInput.value.trim();
            const domCompanyContact = pdfCompanyContactInput.value.trim();
            const domDefaultNotes = pdfDefaultNotesInput.value.trim();
            const domProposalLineColor = pdfProposalLineColorInput.value;

            // --- Read Website URL ---
            const websiteInput = document.getElementById('pdf-company-website'); // Find the input
            const domWebsiteUrl = websiteInput ? websiteInput.value.trim() : ''; // Safely get value
            console.log("[savePdfSettings] Read from DOM - Website URL Input ('#pdf-company-website'):", domWebsiteUrl); // Log 2

            // Log current state BEFORE update
            console.log("[savePdfSettings] currentPdfConfig.companyWebsiteUrl BEFORE update:", currentPdfConfig?.companyWebsiteUrl); // Log 3 (Added safe navigation)

            // --- Update global currentPdfConfig object ---
            // Ensure currentPdfConfig is an object before modifying
            if (typeof currentPdfConfig !== 'object' || currentPdfConfig === null) {
                console.warn("[savePdfSettings] currentPdfConfig was not an object, re-initializing.");
                currentPdfConfig = { ...defaultPdfConfig }; // Re-initialize if it got corrupted
            }
            currentPdfConfig.companyName = domCompanyName;
            currentPdfConfig.companyAddress = domCompanyAddress;
            currentPdfConfig.companyContact = domCompanyContact;
            currentPdfConfig.defaultNotes = domDefaultNotes;
            currentPdfConfig.proposalLineColor = domProposalLineColor;
            currentPdfConfig.companyWebsiteUrl = domWebsiteUrl; // Update the URL

            // Log current state AFTER update
            console.log("[savePdfSettings] currentPdfConfig.companyWebsiteUrl AFTER update:", currentPdfConfig.companyWebsiteUrl); // Log 4
            console.log("[savePdfSettings] Entire currentPdfConfig object state before calling saveCurrentData:", JSON.stringify(currentPdfConfig)); // Log 5

            // --- Call Save ---
            console.log("[savePdfSettings] Calling saveCurrentDataToActiveProfile..."); // Log 6
            if (saveCurrentDataToActiveProfile(feedbackEl)) {
                console.log("[savePdfSettings] saveCurrentDataToActiveProfile reported SUCCESS.");
                // Feedback is shown by saveCurrentDataToActiveProfile
                setSaveButtonState(btnSavePdfSettings, false); // Update button state
                return true;
            } else {
                console.log("[savePdfSettings] saveCurrentDataToActiveProfile reported FAILURE.");
                showFeedback(feedbackEl, "Failed to save PDF settings.", "red"); // Show specific feedback on failure
                return false;
            }
        }

        function saveProposalOptions() {
            // ... (keep existing initial checks and validation setup) ...
            clearValidationErrors(proposalOptionsSection);
            let isValid = true; let firstErrorElement = null;
            const optionsFromDOM = [];
            const rows = proposalOptionsBody.querySelectorAll('tr');

            if (rows.length === 1 && rows[0].cells.length === 1 && rows[0].cells[0].colSpan === 7 && rows[0].cells[0].textContent.startsWith("No options defined")) { // Adjusted colspan check
                // Empty table is valid
            } else {
                rows.forEach((row, rowIndex) => {
                    const optionId = row.getAttribute('data-id'); if (!optionId) return;
                    // --- ADJUSTED Cell Count Check ---
                    if (row.cells.length < 7) { console.warn("Skipping row with incorrect cell count:", row); return; }

                    const nameInput = row.querySelector('.option-name');
                    const descInput = row.querySelector('.option-description');
                    const typeSelect = row.querySelector('.option-type');
                    const valueInput = row.querySelector('.option-value');
                    // --- Get New Checkboxes ---
                    const selectedCheckbox = row.querySelector('.option-default-selected-checkbox');
                    const showCheckbox = row.querySelector('.option-default-show-checkbox');

                    // --- Adjusted validation check ---
                    if (!nameInput || !descInput || !typeSelect || !valueInput || !selectedCheckbox || !showCheckbox) {
                        console.warn("Could not find all inputs/select/textarea/checkboxes in option row:", row); isValid = false;
                        showFeedback(optionsFeedback, `Error: Fields missing in Option Row ${rowIndex + 1}. Save aborted.`, "red", 0); return;
                    }

                    const name = nameInput.value.trim(); const value = parseFloat(valueInput.value); let rowIsValid = true;
                    if (!name) { nameInput.classList.add(INVALID_CLASS); rowIsValid = false; if (!firstErrorElement) firstErrorElement = nameInput; }
                    if (isNaN(value)) { valueInput.classList.add(INVALID_CLASS); rowIsValid = false; if (!firstErrorElement) firstErrorElement = valueInput; }

                    if (!rowIsValid) { isValid = false; }
                    else {
                        // --- Add new properties to the saved object ---
                        optionsFromDOM.push({
                            id: optionId,
                            name: name,
                            description: descInput.value.trim(),
                            type: typeSelect.value,
                            value: value,
                            defaultSelected: selectedCheckbox.checked, // Save state
                            defaultShowOnQuote: showCheckbox.checked   // Save state
                        });
                    }
                });
            }

            if (!isValid) {
                // ... (keep existing error handling) ...
                return false;
            }

            currentProposalOptions = optionsFromDOM;

            if (saveCurrentDataToActiveProfile(optionsFeedback)) {
                displayProposalOptionsSettings(); // Refresh settings display
                displayDashboardOptions();      // Refresh dashboard display
                updateRunningTotals();          // Update totals
                return true;
            }
            return false;
        }

        function saveScopeTemplates() {
            console.log("Attempting to save scope templates to active profile...");
            if (!scopeTemplatesBody || !scopeTemplatesSection || !scopeTemplatesFeedback) {
                console.error("Cannot save, scope template elements missing.");
                return false;
            }
            if (!currentProfileName) {
                showFeedback(scopeTemplatesFeedback, "No active profile. Please create or select a profile first.", "red", 5000);
                if (profileNewNameInput) profileNewNameInput.focus();
                return false;
            }
            clearValidationErrors(scopeTemplatesSection);
            let isValid = true; let firstErrorElement = null; const updatedTemplates = [];
            const rows = scopeTemplatesBody.querySelectorAll('tr');

            if (rows.length === 1 && rows[0].cells.length === 1 && rows[0].cells[0].colSpan === 3 && rows[0].cells[0].textContent.startsWith("No scope templates defined")) {
                // Empty table is valid
            } else {
                rows.forEach((row, rowIndex) => {
                    const templateId = row.getAttribute('data-id'); if (!templateId) return;
                    if (row.cells.length < 2) { console.warn("Skipping scope row with incorrect cell count:", row); return; } // Should be 3 for actions
                    const nameInput = row.querySelector('.scope-name'); const textInput = row.querySelector('.scope-text');
                    if (!nameInput || !textInput) {
                        console.warn("Could not find inputs in scope template row:", row); isValid = false;
                        showFeedback(scopeTemplatesFeedback, `Error: Fields missing in Scope Template Row ${rowIndex + 1}. Save aborted.`, "red", 0); return;
                    }
                    const name = nameInput.value.trim(); const text = textInput.value.trim();
                    // Allow saving an empty text for a named template, but name is required
                    if (!name) { nameInput.classList.add(INVALID_CLASS); isValid = false; if (!firstErrorElement) firstErrorElement = nameInput; }
                    else { updatedTemplates.push({ id: templateId, name: name, text: text }); }
                });
            }

            if (!isValid) {
                console.warn("Validation failed. Scope templates not saved.");
                showFeedback(scopeTemplatesFeedback, "Validation error(s). Please fix highlighted fields and save again.", "red", 0);
                if (firstErrorElement) firstErrorElement.focus();
                return false;
            }

            currentScopeTemplates = updatedTemplates;

            if (saveCurrentDataToActiveProfile(scopeTemplatesFeedback)) {
                displayScopeTemplatesSettings();
                displayDashboardScopeDropdown();
                return true;
            }
            return false;
        }

        function handleLogoFileSelect(event) {
            if (!pdfLogoFileInput || !logoPreview || !logoStatus || !pdfSettingsFeedback) {
                console.warn("Logo handling elements missing. Cannot process logo.");
                return;
            }
            const file = event.target.files ? event.target.files[0] : null;

            logoStatus.textContent = '';
            logoStatus.style.color = '#888';

            if (!file) {
                logoStatus.textContent = 'No file selected.';
                if (currentPdfConfig.logoDataUrl) {
                    currentPdfConfig.logoDataUrl = "";
                    logoPreview.src = "";
                    logoPreview.style.display = 'none';
                    showFeedback(pdfSettingsFeedback, 'Logo cleared. Save PDF Settings to make permanent.', 'orange', 0);
                    setSaveButtonState(btnSavePdfSettings, true);
                    if (currentProfileName) isProfileDirty = true;
                }
                return;
            }

            if (file.size > MAX_LOGO_SIZE_BYTES) {
                logoStatus.textContent = `File too large (max ${MAX_LOGO_SIZE_BYTES / 1024 / 1024}MB).`;
                logoStatus.style.color = 'red';
                pdfLogoFileInput.value = null;
                return;
            }
            if (file.type !== 'image/png' && file.type !== 'image/jpeg') {
                logoStatus.textContent = 'Invalid file type (PNG/JPG only).';
                logoStatus.style.color = 'red';
                pdfLogoFileInput.value = null;
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                const dataUrl = e.target.result;
                if (typeof dataUrl === 'string' && dataUrl.startsWith('data:image')) {
                    currentPdfConfig.logoDataUrl = dataUrl;
                    logoPreview.src = dataUrl;
                    logoPreview.style.display = 'inline-block';
                    logoStatus.textContent = 'Logo preview updated.';
                    logoStatus.style.color = 'green';
                    showFeedback(pdfSettingsFeedback, 'New logo loaded. Click "Save PDF Settings" to apply to this profile.', 'orange', 0);
                    setSaveButtonState(btnSavePdfSettings, true);
                    if (currentProfileName) isProfileDirty = true;
                } else {
                    logoStatus.textContent = 'Error reading logo file data.';
                    logoStatus.style.color = 'red';
                }
            };
            reader.onerror = function () {
                logoStatus.textContent = 'Error loading file with FileReader.';
                logoStatus.style.color = 'red';
            };
            reader.readAsDataURL(file);
        }

        function displayDashboardItems() {
            if (!dashboardItemsDiv) { console.error("Dashboard items container not found."); return; }
            dashboardItemsDiv.innerHTML = ''; // Clear existing items
            if (!Array.isArray(currentItems) || currentItems.length === 0) {
                dashboardItemsDiv.innerHTML = '<p><i>No cost items defined in settings.</i></p>'; return;
            }

            currentItems.forEach((item, index) => {
                const itemContainer = document.createElement('div'); itemContainer.className = 'dashboard-item-container';
                const label = document.createElement('label'); label.className = 'dashboard-item-label'; label.setAttribute('for', `item-qty-${index}`); label.textContent = `${item.name || 'Unnamed Item'}: `; label.title = item.description || item.name || '';
                const inputDiv = document.createElement('div'); inputDiv.className = 'dashboard-item-input';
                const input = document.createElement('input'); input.type = 'number'; input.id = `item-qty-${index}`; input.className = 'dashboard-quantity'; input.name = `item-qty-${index}`; input.min = '0'; input.step = 'any'; input.placeholder = `Enter ${item.unit || 'quantity'}`; input.setAttribute('data-item-index', index);
                const lineTotalSpan = document.createElement('span'); lineTotalSpan.id = `line-total-${index}`; lineTotalSpan.className = 'dashboard-line-total'; lineTotalSpan.textContent = formatCurrency(0);
                inputDiv.appendChild(input); inputDiv.appendChild(lineTotalSpan);
                const descP = document.createElement('div'); descP.className = 'dashboard-item-desc'; descP.textContent = item.description || '';
                itemContainer.appendChild(label); itemContainer.appendChild(inputDiv); itemContainer.appendChild(descP);
                dashboardItemsDiv.appendChild(itemContainer);
                updateLineItemCost(index, input);
            });
        }

        function displayDashboardOptions() {
            if (!dashboardOptionsDiv) { console.error("Dashboard options container not found."); return; }
            dashboardOptionsDiv.innerHTML = '';
            if (!Array.isArray(currentProposalOptions) || currentProposalOptions.length === 0) { dashboardOptionsDiv.innerHTML = '<p><i>No proposal options/adjustments defined in settings.</i></p>'; return; }

            currentProposalOptions.forEach(option => {
                const optionId = option?.id; if (!optionId) { console.warn("Skipping rendering option without ID:", option); return; }
                const optionContainer = document.createElement('div'); optionContainer.className = 'dashboard-option-item'; optionContainer.setAttribute('data-option-id', option.id);

                // --- Left Part: Option Toggle Checkbox + Name ---
                const labelContainer = document.createElement('div'); labelContainer.className = 'label-container';
                const toggleCheckbox = document.createElement('input'); toggleCheckbox.type = 'checkbox'; toggleCheckbox.id = `option-toggle-${option.id}`; toggleCheckbox.className = 'option-toggle-checkbox'; toggleCheckbox.value = option.id;
                // --- SET CHECKED BASED ON DEFAULT ---
                toggleCheckbox.checked = option.defaultSelected ?? false; // Use defaultSelected property
                // ---
                const nameLabel = document.createElement('label'); nameLabel.setAttribute('for', `option-toggle-${option.id}`); nameLabel.textContent = option.name || 'Unnamed Option'; nameLabel.title = option.description || option.name || '';
                labelContainer.appendChild(toggleCheckbox); labelContainer.appendChild(nameLabel);

                // --- Middle Part: Value Input + Type ---
                // ... (value input code remains the same) ...
                const valueContainer = document.createElement('div'); valueContainer.className = 'value-container';
                const valueInput = document.createElement('input'); valueInput.type = 'number'; valueInput.id = `option-value-${option.id}`; valueInput.className = 'option-dashboard-value'; valueInput.step = 'any'; valueInput.value = option.value || 0;
                const typeIndicator = document.createElement('span'); typeIndicator.className = 'value-type-indicator'; typeIndicator.textContent = option.type === 'Percent' ? '%' : '$';
                valueContainer.appendChild(valueInput); valueContainer.appendChild(typeIndicator);


                // --- Middle-Right Part: Show on Quote Checkbox ---
                const showOnQuoteContainer = document.createElement('div'); showOnQuoteContainer.className = 'show-on-quote-container';
                const showCheckbox = document.createElement('input'); showCheckbox.type = 'checkbox'; showCheckbox.id = `option-dashboard-show-${option.id}`; showCheckbox.className = 'option-dashboard-show-toggle';
                // --- SET CHECKED BASED ON DEFAULT ---
                showCheckbox.checked = option.defaultShowOnQuote ?? true; // Use defaultShowOnQuote property
                // ---
                showCheckbox.setAttribute('data-option-id', option.id);
                const showLabel = document.createElement('label'); showLabel.setAttribute('for', `option-dashboard-show-${option.id}`); showLabel.textContent = 'Show on Quote?'; showLabel.title = 'If selected above, check this to include this line item on the customer proposal PDF.';
                showOnQuoteContainer.appendChild(showCheckbox); showOnQuoteContainer.appendChild(showLabel);

                // --- Far-Right Part: Optional Addition Checkbox ---
                // ... (optional checkbox remains the same, default unchecked) ...
                const optionalContainer = document.createElement('div'); optionalContainer.className = 'optional-addition-container';
                const optionalCheckbox = document.createElement('input'); optionalCheckbox.type = 'checkbox'; optionalCheckbox.id = `option-dashboard-is-optional-${option.id}`; optionalCheckbox.className = 'option-dashboard-is-optional'; optionalCheckbox.checked = false; optionalCheckbox.setAttribute('data-option-id', option.id);
                const optionalLabel = document.createElement('label'); optionalLabel.setAttribute('for', `option-dashboard-is-optional-${option.id}`); optionalLabel.textContent = 'Optional?'; optionalLabel.title = 'Check this if the item is an Optional Addition. Its cost will NOT be included in the main Project Total, but listed separately.';
                optionalContainer.appendChild(optionalCheckbox); optionalContainer.appendChild(optionalLabel);

                // Append all sections to the main container
                optionContainer.appendChild(labelContainer);
                optionContainer.appendChild(valueContainer);
                optionContainer.appendChild(showOnQuoteContainer);
                optionContainer.appendChild(optionalContainer);
                dashboardOptionsDiv.appendChild(optionContainer);
            });
            // Important: Trigger initial calculation after setting defaults
            updateRunningTotals();
        }

        function displayDashboardScopeDropdown() {
            if (!scopeTemplateSelect) { console.error("Scope template select dropdown not found."); return; }
            const currentValue = scopeTemplateSelect.value;
            scopeTemplateSelect.innerHTML = '';
            const defaultOption = document.createElement('option'); defaultOption.value = ""; defaultOption.textContent = "-- Select Template or Enter Custom Scope --"; scopeTemplateSelect.appendChild(defaultOption);
            if (Array.isArray(currentScopeTemplates)) {
                const sortedTemplates = [...currentScopeTemplates].sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                sortedTemplates.forEach(template => {
                    const option = document.createElement('option');
                    option.value = template.id || '';
                    option.textContent = template.name || 'Unnamed Template';
                    scopeTemplateSelect.appendChild(option);
                });
            }
            scopeTemplateSelect.value = currentValue;
        }


        // --- Calculations ---
        function updateConcreteCalculatorDisplay() {
            if (!jobAreaInput || !jobThicknessInput || !calculatedConcreteVolumeEl) { return; }
            const sqft = parseFloat(jobAreaInput.value) || 0;
            const thicknessInches = parseFloat(jobThicknessInput.value) || 0;
            let calculatedYards = 0;
            if (sqft > 0 && thicknessInches > 0) {
                const thicknessFeet = thicknessInches / 12;
                const cubicFeet = sqft * thicknessFeet;
                calculatedYards = (cubicFeet / 27) * CONCRETE_WASTE_FACTOR;
            }
            calculatedConcreteVolumeEl.textContent = `~${calculatedYards.toFixed(2)} cu yd`;
        }

        function updateLineItemCost(itemIndex, quantityInput) {
            const lineTotalSpan = document.getElementById(`line-total-${itemIndex}`);
            if (!lineTotalSpan || !quantityInput) { console.warn("Missing elements for line item cost update:", itemIndex); return; }

            const quantity = parseFloat(quantityInput.value) || 0;
            let lineTotal = 0;

            if (quantity > 0 && Array.isArray(currentItems) && itemIndex >= 0 && itemIndex < currentItems.length) {
                const item = currentItems[itemIndex];
                if (item.pricingType === 'Formula' && item.formula) {
                    try {
                        const currentJobArea = parseFloat(jobAreaInput?.value) || 0;
                        const currentJobThickness = parseFloat(jobThicknessInput?.value) || 0;
                        const formulaContext = { quantity: quantity, jobArea: currentJobArea, jobThickness: currentJobThickness };
                        const formulaFunc = new Function(...Object.keys(formulaContext), `return ${item.formula}`);
                        const calculatedValue = formulaFunc(...Object.values(formulaContext));

                        if (!isNaN(calculatedValue) && isFinite(calculatedValue)) {
                            lineTotal = calculatedValue;
                        } else {
                            throw new Error(`Formula result is invalid number: ${calculatedValue}`);
                        }
                    } catch (e) {
                        console.error(`Error evaluating line item formula for '${item.name}': ${item.formula}`, e);
                        lineTotalSpan.textContent = "Error";
                        lineTotalSpan.title = `Formula error: ${e.message}`;
                        return;
                    }
                } else {
                    const itemCost = parseFloat(item?.cost) || 0;
                    lineTotal = quantity * itemCost;
                }
            }
            lineTotalSpan.textContent = formatCurrency(lineTotal);
            lineTotalSpan.title = '';
        }


        function calculateBaseEstimate() {
            let subtotal = 0;
            const currentJobArea = parseFloat(jobAreaInput?.value) || 0;
            const currentJobThickness = parseFloat(jobThicknessInput?.value) || 0;

            // 1. Calculate from permanent items (existing logic)
            if (dashboardItemsDiv) {
                const quantityInputs = dashboardItemsDiv.querySelectorAll('.dashboard-quantity');
                quantityInputs.forEach(input => {
                    const quantity = parseFloat(input.value) || 0;
                    if (quantity > 0) {
                        const itemIndex = parseInt(input.getAttribute('data-item-index'), 10);
                        if (!isNaN(itemIndex) && Array.isArray(currentItems) && itemIndex >= 0 && itemIndex < currentItems.length) {
                            const item = currentItems[itemIndex];
                            let itemTotal = 0;
                            if (item.pricingType === 'Formula' && item.formula) {
                                try {
                                    const formulaContext = { quantity: quantity, jobArea: currentJobArea, jobThickness: currentJobThickness };
                                    const formulaFunc = new Function(...Object.keys(formulaContext), `return ${item.formula}`);
                                    itemTotal = formulaFunc(...Object.values(formulaContext));
                                    if (isNaN(itemTotal) || !isFinite(itemTotal)) { itemTotal = 0; }
                                } catch (e) {
                                    console.error(`Error evaluating formula for item '${item.name}' during total calc: ${item.formula}`, e);
                                    itemTotal = 0;
                                }
                            } else {
                                const itemCost = parseFloat(item?.cost) || 0;
                                itemTotal = quantity * itemCost;
                            }
                            subtotal += itemTotal;
                        } else { console.warn("Could not find item for quantity input index during total calc:", itemIndex, input); }
                    }
                });
            } else {
                console.error("dashboardItemsDiv not found in calculateBaseEstimate.");
            }


            // 2. NEW: Calculate from temporary items
            if (dashboardTempItemsDiv) {
                const tempItemContainers = dashboardTempItemsDiv.querySelectorAll('.dashboard-item-container[data-temp-item-id]');
                tempItemContainers.forEach(container => {
                    const quantityInput = container.querySelector('.temp-item-quantity');
                    const costInput = container.querySelector('.temp-item-cost');

                    const quantity = parseFloat(quantityInput?.value) || 0;
                    const cost = parseFloat(costInput?.value) || 0;

                    if (quantity > 0 && cost >= 0) {
                        subtotal += (quantity * cost);
                    }
                });
            } else {
                console.warn("dashboardTempItemsDiv not found in calculateBaseEstimate, skipping temp items calculation.");
            }


            const markupRate = (parseFloat(currentMarkup) || 0) / 100;
            const markupAmount = subtotal * markupRate;
            const totalBeforeOptions = subtotal + markupAmount;
            return { subtotal: subtotal, markupAmount: markupAmount, totalBeforeOptions: totalBeforeOptions, markupPercent: currentMarkup };
        }

        function calculateOptionsAndFinalTotal(baseEstimate) {
            let totalOptionsAdjustment = 0; // Sum of non-optional adjustments (including their markup)
            let additionalMarkupAmount = 0; // Markup explicitly added to adjustments

            // Lists to collect details for PDF display later
            const appliedAdjustmentsListForPdf = []; // For non-optional adjustments that affect main total
            const optionalAdditionsListForPdf = []; // For items explicitly marked optional (including markup if applied)

            if (!dashboardOptionsDiv || !Array.isArray(currentProposalOptions) || !dashboardTempOptionsDiv) {
                console.error("Missing elements for option/adjustment calculation.");
                return {
                    optionsAdjustment: 0,
                    grandTotal: baseEstimate.totalBeforeOptions,
                    appliedOptionsList: [],
                    optionalAdditionsList: [],
                    additionalMarkupAmount: 0,
                    newSubtotal: baseEstimate.subtotal,
                    newMarkupAmount: baseEstimate.markupAmount,
                    newTotalBeforeOptions: baseEstimate.totalBeforeOptions
                };
            }

            const markupRate = (parseFloat(currentMarkup) || 0) / 100;

            // --- Process Permanent Proposal Options / Adjustments ---
            const permanentOptionItems = dashboardOptionsDiv.querySelectorAll('.dashboard-option-item[data-option-id]');
            permanentOptionItems.forEach((item) => {
                const toggleCheckbox = item.querySelector('.option-toggle-checkbox');
                const valueInput = item.querySelector('.option-dashboard-value');
                const optionId = item.getAttribute('data-option-id');
                const isOptionalCheckbox = item.querySelector('.option-dashboard-is-optional');
                const dashboardShowCheckbox = item.querySelector('.option-dashboard-show-toggle');

                if (toggleCheckbox?.checked && valueInput && optionId) {
                    const isOptional = isOptionalCheckbox?.checked ?? false;
                    const optionDef = currentProposalOptions.find(opt => opt.id === optionId);

                    if (optionDef) {
                        let adjustmentValue = parseFloat(valueInput.value) || 0;
                        let finalAmountForThisAdjustment = adjustmentValue; // Start with base value

                        if (optionDef.type === 'Percent') {
                            // Permanent percent adjustments apply to the baseEstimate.totalBeforeOptions
                            // (which is the current sum of items + their markup)
                            finalAmountForThisAdjustment = baseEstimate.totalBeforeOptions * (adjustmentValue / 100);
                        }

                        if (isOptional) { // Permanent Optional item
                            if (dashboardShowCheckbox?.checked) { // Only add to PDF list if also marked to show
                                optionalAdditionsListForPdf.push({
                                    name: optionDef.name || 'Unnamed Optional',
                                    description: optionDef.description || '',
                                    amount: finalAmountForThisAdjustment,
                                    type: optionDef.type, // Keep type for PDF display clarity
                                    isOptional: true,
                                    isTemp: false,
                                    showOnQuote: true // Implicitly true if added to this list
                                });
                            }
                        } else { // Permanent Standard Adjustment (not optional, applied AFTER markup)
                            totalOptionsAdjustment += finalAmountForThisAdjustment;
                            if (dashboardShowCheckbox?.checked) {
                                appliedAdjustmentsListForPdf.push({
                                    name: optionDef.name || 'Unnamed Adjustment',
                                    description: optionDef.description || '',
                                    amount: finalAmountForThisAdjustment,
                                    type: optionDef.type,
                                    isOptional: false,
                                    isTemp: false,
                                    showOnQuote: true // Implicitly true if added to this list
                                });
                            }
                        }
                    } else {
                        console.warn(`Definition not found for permanent selected adjustment ID: ${optionId}`);
                    }
                }
            });

            // --- Process Temporary Proposal Options / Adjustments ---
            const tempOptionItems = dashboardTempOptionsDiv.querySelectorAll('.dashboard-option-item[data-temp-option-id]');
            tempOptionItems.forEach(container => {
                const nameInput = container.querySelector('.temp-option-name');
                const descInput = container.querySelector('.temp-option-description');
                const typeSelect = container.querySelector('.temp-option-type');
                const valueInput = container.querySelector('.temp-option-value'); // This now contains the *displayed* value (potentially marked up)
                const applyMarkupCheckbox = container.querySelector('.temp-option-apply-markup');
                const isOptionalCheckbox = container.querySelector('.temp-option-is-optional');
                const showOnQuoteCheckbox = container.querySelector('.temp-option-show-on-quote'); // NEW: Show on Quote checkbox

                const name = nameInput?.value.trim() || 'Unnamed Temp Adjustment';
                const description = descInput?.value.trim() || '';
                const type = typeSelect?.value || 'Fixed';
                const displayedValue = parseFloat(valueInput?.value) || 0; // Get the displayed value
                const applyMarkup = applyMarkupCheckbox?.checked ?? false;
                const isOptional = isOptionalCheckbox?.checked ?? false;
                const showOnQuote = showOnQuoteCheckbox?.checked ?? true; // Default to true

                // Calculate the original base value of the adjustment (before any markup was applied to it)
                let baseValueForCalc = displayedValue;
                if (type === 'Fixed' && applyMarkup && markupRate > 0) {
                    baseValueForCalc = displayedValue / (1 + markupRate);
                }

                let finalAmountForThisAdjustment = baseValueForCalc; // This is the base value of the adjustment itself
                let markupOnThisAdjustment = 0; // Markup calculated on *this specific adjustment*

                if (type === 'Percent') {
                    // For temporary percentage adjustments, they apply to the *base estimate's total before options*
                    // which is (items + markup on items). This ensures percentages are calculated on a consistent base.
                    finalAmountForThisAdjustment = baseEstimate.totalBeforeOptions * (baseValueForCalc / 100);
                }

                // If it applies markup, calculate that specific markup amount
                if (applyMarkup) {
                    // Markup is calculated on the base value of this adjustment (finalAmountForThisAdjustment)
                    markupOnThisAdjustment = finalAmountForThisAdjustment * markupRate;
                    additionalMarkupAmount += markupOnThisAdjustment; // Accumulate this markup to the overall additional markup
                }

                if (isOptional) { // Temporary Optional item
                    if (showOnQuote) { // Only add to PDF list if also marked to show
                        optionalAdditionsListForPdf.push({
                            name: name,
                            description: description,
                            amount: finalAmountForThisAdjustment + markupOnThisAdjustment, // Include its own markup in optional amount
                            type: type,
                            isOptional: true,
                            isTemp: true,
                            showOnQuote: showOnQuote
                        });
                    }
                } else { // Temporary Standard Adjustment (not optional)
                    // Add the base value of this adjustment AND its calculated markup to totalOptionsAdjustment
                    totalOptionsAdjustment += finalAmountForThisAdjustment;
                    // Note: We are no longer adding `additionalMarkupAmount` to `totalOptionsAdjustment` directly here.
                    // The `markupOnThisAdjustment` *is* the additional markup for THIS item, which we add here.
                    totalOptionsAdjustment += markupOnThisAdjustment;

                    if (showOnQuote) { // Only add to PDF list if also marked to show
                        appliedAdjustmentsListForPdf.push({
                            name: name,
                            description: description,
                            amount: finalAmountForThisAdjustment + markupOnThisAdjustment, // Total amount including its own markup
                            type: type,
                            isOptional: false,
                            isTemp: true,
                            appliesMarkup: applyMarkup, // Flag for PDF clarity
                            showOnQuote: showOnQuote
                        });
                    }
                }
            });

            // --- Final Calculation ---
            // The grand total now includes:
            // 1. The base estimate's total before options (items + markup on items)
            // 2. Any additional markup calculated on temporary adjustments (`additionalMarkupAmount`)
            // 3. The total of all non-optional adjustments (`totalOptionsAdjustment`), which now
            //    already includes their own markup.
            const grandTotal = baseEstimate.totalBeforeOptions + totalOptionsAdjustment; // `additionalMarkupAmount` is already part of `totalOptionsAdjustment`

            return {
                optionsAdjustment: totalOptionsAdjustment, // This now correctly represents all post-markup adjustments
                grandTotal: grandTotal,
                appliedOptionsList: appliedAdjustmentsListForPdf, // List of non-optional adjustments for PDF
                optionalAdditionsList: optionalAdditionsListForPdf, // List of optional items for PDF
                additionalMarkupAmount: additionalMarkupAmount, // Sum of all markup specifically from temporary adjustments
                // Pass new totals based on the *final* markup amount for the display/PDFs
                newSubtotal: baseEstimate.subtotal, // This remains fixed for items
                newMarkupAmount: baseEstimate.markupAmount + additionalMarkupAmount, // Items markup + adjustments markup
                newTotalBeforeOptions: baseEstimate.totalBeforeOptions + additionalMarkupAmount // Base total before options that DON'T get markup
            };
        }

        // --- Update getSelectedOptionalAdditionsData to use new showOnQuote and include temporary options' markup ---
        // This function should consolidate ALL optional items (permanent and temporary) that are
        // intended to be displayed in the "Optional Additions" section.
        function getSelectedOptionalAdditionsData() {
            const selectedOptionals = [];
            if (!dashboardOptionsDiv || !Array.isArray(currentProposalOptions) || !dashboardTempOptionsDiv) {
                console.error("Missing elements for optional additions data gathering.");
                return selectedOptionals;
            }

            // Get the current grand total from a fresh calculation to use for percentage optionals
            const baseEstimate = calculateBaseEstimate();
            const calculationResults = calculateOptionsAndFinalTotal(baseEstimate);
            const currentGrandTotal = calculationResults.grandTotal;
            const markupRate = (parseFloat(currentMarkup) || 0) / 100;

            // Process permanent optional additions
            const permanentOptionItems = dashboardOptionsDiv.querySelectorAll('.dashboard-option-item[data-option-id]');
            permanentOptionItems.forEach((item) => {
                const toggleCheckbox = item.querySelector('.option-toggle-checkbox');
                const isOptionalCheckbox = item.querySelector('.option-dashboard-is-optional');
                const valueInput = item.querySelector('.option-dashboard-value');
                const optionId = item.getAttribute('data-option-id');
                const showOnQuoteCheckbox = item.querySelector('.option-dashboard-show-toggle');

                if (toggleCheckbox?.checked && isOptionalCheckbox?.checked && valueInput && optionId && (showOnQuoteCheckbox?.checked ?? false)) { // Only if selected and shown
                    const optionDef = currentProposalOptions.find(opt => opt.id === optionId);
                    if (optionDef) {
                        let amount = parseFloat(valueInput.value) || 0;
                        if (optionDef.type === 'Percent') {
                            amount = currentGrandTotal * (amount / 100);
                        }
                        selectedOptionals.push({
                            id: optionDef.id,
                            name: optionDef.name || 'Unnamed Optional',
                            description: optionDef.description || '',
                            amount: amount,
                            type: optionDef.type,
                            showOnQuote: true, // Already filtered by this
                            isOptional: true,
                            isTemp: false
                        });
                    } else { console.warn(`Definition not found for permanent optional option ID: ${optionId}`); }
                }
            });

            // Process temporary options explicitly marked as "Make Optional?"
            const tempOptionItems = dashboardTempOptionsDiv.querySelectorAll('.dashboard-option-item[data-temp-option-id]');
            tempOptionItems.forEach(container => {
                const nameInput = container.querySelector('.temp-option-name');
                const descInput = container.querySelector('.temp-option-description');
                const typeSelect = container.querySelector('.temp-option-type');
                const valueInput = container.querySelector('.temp-option-value');
                const isOptionalCheckbox = container.querySelector('.temp-option-is-optional');
                const showOnQuoteCheckbox = container.querySelector('.temp-option-show-on-quote'); // NEW: Show on Quote checkbox
                const applyMarkupCheckbox = container.querySelector('.temp-option-apply-markup');


                const name = nameInput?.value.trim() || 'Unnamed Temp Optional';
                const description = descInput?.value.trim() || '';
                const type = typeSelect?.value || 'Fixed';
                const displayedValue = parseFloat(valueInput?.value) || 0;
                const isOptional = isOptionalCheckbox?.checked ?? false;
                const showOnQuote = showOnQuoteCheckbox?.checked ?? true;
                const applyMarkup = applyMarkupCheckbox?.checked ?? false;


                // Only include if it's explicitly marked optional AND shown on quote AND has a non-zero value
                if (isOptional && showOnQuote && displayedValue !== 0) {
                    let baseValueForCalc = displayedValue;
                    if (type === 'Fixed' && applyMarkup && markupRate > 0) {
                        baseValueForCalc = displayedValue / (1 + markupRate); // Reverse calc to get original cost for markup
                    }

                    let amount = baseValueForCalc;
                    if (type === 'Percent') {
                        amount = currentGrandTotal * (baseValueForCalc / 100); // Apply percentage to the current grand total
                    }

                    // If markup was applied to this optional, add that markup amount to its display
                    let markupOnThisOptional = 0;
                    if (applyMarkup) {
                        markupOnThisOptional = amount * markupRate;
                    }

                    selectedOptionals.push({
                        id: container.getAttribute('data-temp-option-id'),
                        name: name,
                        description: description,
                        amount: amount + markupOnThisOptional, // Include its own markup in optional amount
                        type: type,
                        showOnQuote: showOnQuote,
                        isOptional: true,
                        isTemp: true,
                        appliesMarkup: applyMarkup // For internal PDF clarity
                    });
                }
            });
            return selectedOptionals;
        }

        // --- Refactor _getAllSelectedOptionsDataForInternal to handle markup and optional flags for internal PDF ---
        // This function needs to return ALL selected options, correctly categorizing and calculating their amounts.
        // It will now receive the *final* grand total to calculate percentage options against.
        function _getAllSelectedOptionsDataForInternal(finalGrandTotal, baseEstimate) { // Pass finalGrandTotal and baseEstimate
            const allSelectedItems = [];
            if (!dashboardOptionsDiv || !Array.isArray(currentProposalOptions) || !dashboardTempOptionsDiv) {
                console.error("Missing elements for internal PDF option data gathering.");
                return allSelectedItems;
            }

            const markupRate = (parseFloat(baseEstimate.markupPercent) || 0) / 100;

            // --- Process Permanent Proposal Options ---
            const permanentOptionItems = dashboardOptionsDiv.querySelectorAll('.dashboard-option-item[data-option-id]');
            permanentOptionItems.forEach((item) => {
                const toggleCheckbox = item.querySelector('.option-toggle-checkbox');
                const valueInput = item.querySelector('.option-dashboard-value');
                const optionId = item.getAttribute('data-option-id');
                const isOptionalCheckbox = item.querySelector('.option-dashboard-is-optional');

                if (toggleCheckbox?.checked && valueInput && optionId) {
                    const optionDef = currentProposalOptions.find(opt => opt.id === optionId);
                    if (optionDef) {
                        const value = parseFloat(valueInput.value) || 0;
                        const isOptional = isOptionalCheckbox?.checked ?? false;
                        let calculatedAmount = value; // Default to fixed value

                        if (optionDef.type === 'Percent') {
                            // Permanent % adjustments (both optional and non-optional) apply to the finalGrandTotal
                            calculatedAmount = finalGrandTotal * (value / 100);
                        }

                        allSelectedItems.push({
                            name: optionDef.name || 'Unnamed Item',
                            description: optionDef.description || '',
                            amount: calculatedAmount,
                            isOptional: isOptional,
                            isTemp: false,
                            appliesMarkup: false // Permanent options don't have this flag
                        });
                    } else {
                        console.warn(`(Internal PDF) Definition NOT FOUND for permanent selected option ID: ${optionId}`);
                    }
                }
            });

            // --- Process Temporary Proposal Options / Adjustments ---
            const tempOptionItems = dashboardTempOptionsDiv.querySelectorAll('.dashboard-option-item[data-temp-option-id]');
            tempOptionItems.forEach(container => {
                const nameInput = container.querySelector('.temp-option-name');
                const descInput = container.querySelector('.temp-option-description');
                const typeSelect = container.querySelector('.temp-option-type');
                const valueInput = container.querySelector('.temp-option-value'); // This is the displayed value
                const applyMarkupCheckbox = container.querySelector('.temp-option-apply-markup');
                const isOptionalCheckbox = container.querySelector('.temp-option-is-optional');
                const showOnQuoteCheckbox = container.querySelector('.temp-option-show-on-quote');

                const name = nameInput?.value.trim() || 'Unnamed Temp Adjustment';
                const description = descInput?.value.trim() || '';
                const type = typeSelect?.value || 'Fixed';
                const displayedValue = parseFloat(valueInput?.value) || 0;
                const applyMarkup = applyMarkupCheckbox?.checked ?? false;
                const isOptional = isOptionalCheckbox?.checked ?? false;
                const showOnQuote = showOnQuoteCheckbox?.checked ?? true; // Default to true

                if (displayedValue !== 0) {
                    let baseValueForCalc = displayedValue;
                    if (type === 'Fixed' && applyMarkup && markupRate > 0) {
                        // Reverse calculate to get the original base amount for displaying the components
                        baseValueForCalc = displayedValue / (1 + markupRate);
                    }

                    let amount = baseValueForCalc;
                    if (type === 'Percent') {
                        // Temporary percentage options apply to the finalGrandTotal for internal clarity
                        amount = finalGrandTotal * (baseValueForCalc / 100);
                    }

                    // For Internal PDF, we want to show the full amount including markup if applicable
                    let totalAmountForDisplay = amount;
                    if (applyMarkup) {
                        totalAmountForDisplay += (amount * markupRate);
                    }

                    allSelectedItems.push({
                        name: name,
                        description: description,
                        amount: totalAmountForDisplay,
                        isOptional: isOptional,
                        isTemp: true,
                        appliesMarkup: applyMarkup, // Indicate on internal PDF
                        showOnQuote: showOnQuote // For internal PDF clarity
                    });
                }
            });
            return allSelectedItems;
        }

        // --- Update updateRunningTotals to use new calculation results ---
        function updateRunningTotals() {
            // First calculate the base estimate (only cost items)
            const baseEstimate = calculateBaseEstimate();

            // Then calculate all options and adjustments
            const calculationResults = calculateOptionsAndFinalTotal(baseEstimate);

            // Fetch optional additions list separately for display
            const selectedOptionals = getSelectedOptionalAdditionsData();
            const sqft = parseFloat(jobAreaInput?.value) || 0;

            // Update main display using values from calculationResults
            if (runningSubtotalEl) runningSubtotalEl.textContent = formatCurrency(calculationResults.newSubtotal); // Use newSubtotal (base items cost)
            if (runningMarkupPercentEl) runningMarkupPercentEl.textContent = parseFloat(baseEstimate.markupPercent || 0).toFixed(1);
            if (runningMarkupAmountEl) runningMarkupAmountEl.textContent = formatCurrency(calculationResults.newMarkupAmount); // Use newMarkupAmount (items markup + adjustment markup)
            if (runningTotalBeforeOptionsEl) runningTotalBeforeOptionsEl.textContent = formatCurrency(calculationResults.newTotalBeforeOptions); // Base + total markup
            if (runningOptionsAdjustmentEl) runningOptionsAdjustmentEl.textContent = formatCurrency(calculationResults.optionsAdjustment); // This is total of all adjustments (including their markup)
            if (runningGrandTotalEl) runningGrandTotalEl.textContent = formatCurrency(calculationResults.grandTotal);

            const franchiseFee = calculationResults.grandTotal * 0.08;
            // Profit After Fee now based on the NEW total markup amount
            const profitAfterFee = calculationResults.newMarkupAmount - franchiseFee;
            const pricePerSqft = sqft > 0 ? calculationResults.grandTotal / sqft : 0;
            if (runningFranchiseFeeEl) runningFranchiseFeeEl.textContent = formatCurrency(franchiseFee);
            if (runningProfitAfterFeeEl) runningProfitAfterFeeEl.textContent = formatCurrency(profitAfterFee);
            if (runningPricePerSqftEl) runningPricePerSqftEl.textContent = formatCurrency(pricePerSqft);

            // Update optional additions display
            if (dashboardOptionalItemsListDiv) {
                dashboardOptionalItemsListDiv.innerHTML = '';
                // Only show optional additions that are actually marked to be shown on the quote (showOnQuote: true)
                const finalOptionalsForDisplay = selectedOptionals.filter(opt => opt.showOnQuote);
                if (finalOptionalsForDisplay.length > 0) {
                    finalOptionalsForDisplay.forEach(opt => {
                        const itemDiv = document.createElement('div');
                        itemDiv.style.display = 'flex'; itemDiv.style.justifyContent = 'space-between'; itemDiv.style.marginBottom = '5px'; itemDiv.style.fontSize = '1em';
                        const nameSpan = document.createElement('span'); nameSpan.textContent = opt.name; nameSpan.style.marginRight = '10px';
                        const amountSpan = document.createElement('span'); amountSpan.textContent = formatCurrency(opt.amount); amountSpan.style.fontWeight = 'bold';
                        itemDiv.appendChild(nameSpan); itemDiv.appendChild(amountSpan);
                        dashboardOptionalItemsListDiv.appendChild(itemDiv);
                    });
                } else {
                    dashboardOptionalItemsListDiv.innerHTML = '<p><i>None selected.</i></p>';
                }
            } else { console.warn("Dashboard optional items list div not found for update."); }
        }

        function clearQuantities() {
            if (!dashboardItemsDiv) { return; }
            const quantityInputs = dashboardItemsDiv.querySelectorAll('.dashboard-quantity');
            quantityInputs.forEach((input) => {
                input.value = '';
                const lineTotalSpan = input.closest('.dashboard-item-input')?.querySelector('.dashboard-line-total');
                if (lineTotalSpan) { lineTotalSpan.textContent = formatCurrency(0); }
            });

            // NEW: Clear temporary items
            if (dashboardTempItemsDiv) {
                dashboardTempItemsDiv.innerHTML = '<p><i>No temporary items added.</i></p>';
            }

            updateRunningTotals();
            console.log("Dashboard quantities and temporary items cleared.");
            saveDashboardStateToSession();
        }

        function clearJobInfo() {
            if (clientNameInput) clientNameInput.value = '';
            if (projectInfoInput) projectInfoInput.value = '';
            if (scopeOfWorkInput) scopeOfWorkInput.value = '';
            if (scopeTemplateSelect) scopeTemplateSelect.value = '';
            if (jobAreaInput) jobAreaInput.value = '';
            if (jobThicknessInput) jobThicknessInput.value = '';
            if (dashboardScratchpad) dashboardScratchpad.value = '';
            updateConcreteCalculatorDisplay();
            updateRunningTotals();
            console.log("Dashboard job info fields cleared.");
            // --- Save the cleared state ---
            saveDashboardStateToSession();
        }

        function saveDashboardStateToSession() {
            console.log("[Session Save] === Function Called ===");
            try {
                const quantities = [];
                dashboardItemsDiv?.querySelectorAll('.dashboard-quantity').forEach(input => {
                    quantities.push(input.value || '');
                });
                console.log("[Session Save] Quantities read from DOM:", quantities);

                // NEW: Gather temporary items
                const tempItems = [];
                dashboardTempItemsDiv?.querySelectorAll('.dashboard-item-container[data-temp-item-id]').forEach(container => {
                    tempItems.push({
                        id: container.getAttribute('data-temp-item-id'),
                        name: container.querySelector('.temp-item-name')?.value || '',
                        cost: parseFloat(container.querySelector('.temp-item-cost')?.value) || 0,
                        description: container.querySelector('.temp-item-description')?.value || '',
                        quantity: parseFloat(container.querySelector('.temp-item-quantity')?.value) || 0
                    });
                });
                console.log("[Session Save] Temporary items read from DOM:", tempItems);
                // NEW: Gather temporary proposal options/adjustments
                const tempOptions = [];
                dashboardTempOptionsDiv?.querySelectorAll('.dashboard-option-item[data-temp-option-id]').forEach(container => {
                    tempOptions.push({
                        id: container.getAttribute('data-temp-option-id'),
                        name: container.querySelector('.temp-option-name')?.value || '',
                        description: container.querySelector('.temp-option-description')?.value || '',
                        type: container.querySelector('.temp-option-type')?.value || 'Fixed',
                        // Store the original base value for markup calculation logic, not the displayed value
                        value: parseFloat(container.querySelector('.temp-option-value')?.value) / ((container.querySelector('.temp-option-apply-markup')?.checked && container.querySelector('.temp-option-type')?.value === 'Fixed') ? (1 + (parseFloat(currentMarkup) || 0) / 100) : 1) || 0,
                        applyMarkup: container.querySelector('.temp-option-apply-markup')?.checked ?? false,
                        isOptional: container.querySelector('.temp-option-is-optional')?.checked ?? false,
                        showOnQuote: container.querySelector('.temp-option-show-on-quote')?.checked ?? true // NEW: save showOnQuote
                    });
                });
                console.log("[Session Save] Temporary proposal options read from DOM:", tempOptions);

                const optionStates = {};
                dashboardOptionsDiv?.querySelectorAll('.dashboard-option-item').forEach(item => {
                    const optionId = item.getAttribute('data-option-id');
                    if (optionId) {
                        optionStates[optionId] = {
                            selected: item.querySelector('.option-toggle-checkbox')?.checked ?? false,
                            value: item.querySelector('.option-dashboard-value')?.value ?? 0,
                            showOnQuote: item.querySelector('.option-dashboard-show-toggle')?.checked ?? true,
                            isOptional: item.querySelector('.option-dashboard-is-optional')?.checked ?? false,
                        };
                    }
                });
                console.log("[Session Save] Option states read from DOM:", optionStates);

                const clientNameValue = clientNameInput?.value ?? '';
                const projectInfoValue = projectInfoInput?.value ?? '';
                const scopeOfWorkValue = scopeOfWorkInput?.value ?? '';
                const jobAreaValue = jobAreaInput?.value ?? '';
                const jobThicknessValue = jobThicknessInput?.value ?? '';
                const scratchpadValue = dashboardScratchpad?.value ?? '';

                console.log("[Session Save] Client Name from DOM:", clientNameValue);
                console.log("[Session Save] Project Info from DOM:", projectInfoValue);
                console.log("[Session Save] Scope from DOM:", scopeOfWorkValue);
                console.log("[Session Save] Area from DOM:", jobAreaValue);
                console.log("[Session Save] Thickness from DOM:", jobThicknessValue);
                console.log("[Session Save] Scratchpad from DOM:", scratchpadValue);


                const dashboardState = {
                    clientName: clientNameValue,
                    projectInfo: projectInfoValue,
                    scopeOfWork: scopeOfWorkValue,
                    jobArea: jobAreaValue,
                    jobThickness: jobThicknessValue,
                    scratchpad: scratchpadValue,
                    quantities: quantities,
                    options: optionStates,
                    tempItems: tempItems, // NEW: Add temporary items
                    tempOptions: tempOptions // NEW: Add temporary options
                };
                console.log("[Session Save] dashboardState object prepared for saving:", dashboardState);

                sessionStorage.setItem(DASHBOARD_STATE_KEY, JSON.stringify(dashboardState));
                console.log("[Session Save] === Dashboard state saved successfully ===");

            } catch (error) {
                console.error("[Session Save] === Error saving dashboard state ===", error);
            }
        }

        function restoreDashboardStateFromSession() {
            console.log("[Session Restore] === Function Called ===");
            try {
                const savedStateString = sessionStorage.getItem(DASHBOARD_STATE_KEY);
                console.log("[Session Restore] Raw data string from sessionStorage:", savedStateString);
                if (!savedStateString) {
                    console.log("[Session Restore] No saved dashboard state found in sessionStorage. Exiting restore.");
                    updateRunningTotals();
                    updateConcreteCalculatorDisplay();
                    // Clear temporary items display if no state to restore
                    if (dashboardTempItemsDiv) {
                        dashboardTempItemsDiv.innerHTML = '<p><i>No temporary items added.</i></p>';
                    }
                    return;
                }

                const savedState = JSON.parse(savedStateString);
                console.log("[Session Restore] Parsed savedState object:", savedState);

                // Restore simple inputs
                if (clientNameInput) { clientNameInput.value = savedState.clientName ?? ''; } else { console.warn("[Session Restore] clientNameInput not found!"); }
                if (projectInfoInput) { projectInfoInput.value = savedState.projectInfo ?? ''; } else { console.warn("[Session Restore] projectInfoInput not found!"); }
                if (scopeOfWorkInput) { scopeOfWorkInput.value = savedState.scopeOfWork ?? ''; } else { console.warn("[Session Restore] scopeOfWorkInput not found!"); }
                if (jobAreaInput) { jobAreaInput.value = savedState.jobArea ?? ''; } else { console.warn("[Session Restore] jobAreaInput not found!"); }
                if (jobThicknessInput) { jobThicknessInput.value = savedState.jobThickness ?? ''; } else { console.warn("[Session Restore] jobThicknessInput not found!"); }
                if (dashboardScratchpad) { dashboardScratchpad.value = savedState.scratchpad ?? ''; } else { console.warn("[Session Restore] dashboardScratchpad not found!"); }

                // Restore quantities
                const quantityInputs = dashboardItemsDiv?.querySelectorAll('.dashboard-quantity');
                console.log(`[Session Restore] Found ${quantityInputs?.length ?? 0} quantity input elements.`);
                if (quantityInputs && Array.isArray(savedState.quantities)) {
                    console.log("[Session Restore] Restoring quantities array:", savedState.quantities);
                    quantityInputs.forEach((input, index) => {
                        if (index < savedState.quantities.length) {
                            input.value = savedState.quantities[index];
                            const itemIndex = parseInt(input.getAttribute('data-item-index'), 10);
                            if (!isNaN(itemIndex)) { updateLineItemCost(itemIndex, input); }
                        }
                    });
                } else { console.warn("[Session Restore] quantityInputs not found or savedState.quantities is not an array."); }

                // NEW: Restore temporary items
                if (dashboardTempItemsDiv) {
                    dashboardTempItemsDiv.innerHTML = ''; // Clear initial message
                    if (Array.isArray(savedState.tempItems) && savedState.tempItems.length > 0) {
                        console.log("[Session Restore] Restoring temporary items:", savedState.tempItems);
                        savedState.tempItems.forEach(tempItem => addTempItemToDashboard(tempItem));
                    } else {
                        dashboardTempItemsDiv.innerHTML = '<p><i>No temporary items added.</i></p>';
                    }
                } else { console.warn("[Session Restore] dashboardTempItemsDiv not found!"); }

                // NEW: Restore temporary proposal options/adjustments
                if (dashboardTempOptionsDiv) {
                    dashboardTempOptionsDiv.innerHTML = ''; // Clear initial message
                    if (Array.isArray(savedState.tempOptions) && savedState.tempOptions.length > 0) {
                        console.log("[Session Restore] Restoring temporary options:", savedState.tempOptions);
                        savedState.tempOptions.forEach(tempOption => addTempOptionToDashboard(tempOption));
                    } else {
                        dashboardTempOptionsDiv.innerHTML = '<p><i>No temporary options added.</i></p>';
                    }
                } else { console.warn("[Session Restore] dashboardTempOptionsDiv not found!"); }

                // Restore option states
                const optionItems = dashboardOptionsDiv?.querySelectorAll('.dashboard-option-item');
                console.log(`[Session Restore] Found ${optionItems?.length ?? 0} option item elements.`);
                if (optionItems && typeof savedState.options === 'object') {
                    console.log("[Session Restore] Restoring options object:", savedState.options);
                    optionItems.forEach(item => {
                        const optionId = item.getAttribute('data-option-id');
                        if (optionId && savedState.options[optionId]) {
                            const state = savedState.options[optionId];
                            const toggleCheckbox = item.querySelector('.option-toggle-checkbox');
                            const valueInput = item.querySelector('.option-dashboard-value');
                            const showCheckbox = item.querySelector('.option-dashboard-show-toggle');
                            const optionalCheckbox = item.querySelector('.option-dashboard-is-optional');

                            if (toggleCheckbox) toggleCheckbox.checked = state.selected ?? false;
                            if (valueInput) valueInput.value = state.value ?? 0;
                            if (showCheckbox) showCheckbox.checked = state.showOnQuote ?? true;
                            if (optionalCheckbox) optionalCheckbox.checked = state.isOptional ?? false;
                        } else { console.warn(`[Session Restore] State for optionId ${optionId} not found in saved data.`); }
                    });
                } else { console.warn("[Session Restore] optionItems not found or savedState.options is not an object."); }

                // Crucially, recalculate totals after restoring everything
                console.log("[Session Restore] Calling updateRunningTotals() and updateConcreteCalculatorDisplay()...");
                updateRunningTotals();
                updateConcreteCalculatorDisplay();
                console.log("[Session Restore] === Function Finished Successfully ===");

            } catch (error) {
                console.error("[Session Restore] === Error during restore ===", error);
                sessionStorage.removeItem(DASHBOARD_STATE_KEY);
                // Also clear temp items display on restore error
                if (dashboardTempItemsDiv) {
                    dashboardTempItemsDiv.innerHTML = '<p><i>No temporary items added.</i></p>';
                }
                if (dashboardTempOptionsDiv) { // NEW: Clear temp options on error
                    dashboardTempOptionsDiv.innerHTML = '<p><i>No temporary options added.</i></p>';
                }
                updateRunningTotals();
                updateConcreteCalculatorDisplay();
            }
        }

        function clearDashboardStateFromSession() {
            try {
                sessionStorage.removeItem(DASHBOARD_STATE_KEY);
                console.log("[Session Storage] Dashboard state cleared.");
            } catch (error) {
                console.error("[Session Storage] Error clearing dashboard state:", error);
            }
        }
        // === JS_CORE_LOGIC END ===

        // === JS_BACKUP_RESTORE START ===
        function exportSettings() {
            console.log("Export: profileFeedbackSpan is:", profileFeedbackSpan);
            if (!currentProfileName) {
                showFeedback(profileFeedbackSpan, "No active profile selected to export. Please select or create a profile.", "orange", 5000); // <<< CORRECTED
                return;
            }
            console.log(`Exporting settings for active profile: ${currentProfileName}...`);
            try {
                // Construct the data object for the current profile, similar to saving
                const settingsToExport = {
                    // It's good practice to include the profileName in the export
                    // in case the filename gets changed.
                    profileName: currentProfileName,
                    items: currentItems,
                    markup: currentMarkup,
                    pdfConfig: currentPdfConfig,
                    proposalOptions: currentProposalOptions,
                    scopeTemplates: currentScopeTemplates
                };

                const jsonString = JSON.stringify(settingsToExport, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);

                // Generate a filename that includes the profile name
                const filename = `ConcreteEstimator_Profile_${sanitizeForFilename(currentProfileName)}_${BACKUP_FILE_NAME.replace('concrete_estimator_settings_', 'settings_')}`;
                link.download = filename;

                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                showFeedback(profileFeedbackSpan, `Settings for profile '${currentProfileName}' exported to ${filename}`, 'green'); // <<< CORRECTED

            } catch (error) {
                console.error("Error exporting profile:", error);
                showFeedback(profileFeedbackSpan, `Error exporting profile '${currentProfileName}': ${error.message}`, 'red'); // <<< CORRECTED
                alert(`Error exporting profile: ${error.message}`);
            }
        }

        function triggerImport() {
            if (importFileInput) { importFileInput.click(); }
            else {
                console.error("Import file input element not found.");
                showBackupRestoreFeedback("Import error: File input missing.", 'red');
            }
        }

        function importSettings(event) {
            console.log("Import: profileFeedbackSpan is:", profileFeedbackSpan);
            const file = event.target.files ? event.target.files[0] : null;
            if (!file) {
                if (event.target) event.target.value = null; // Clear file input
                return;
            }

            if (!file.name.endsWith('.json')) {
                showFeedback(profileFeedbackSpan, "Invalid file type for import (must be .json).", 'red'); // <<< CORRECTED
                if (event.target) event.target.value = null;
                return;
            }

            const reader = new FileReader();

            reader.onload = function (e) {
                const fileContent = e.target.result;
                if (typeof fileContent !== 'string') {
                    showFeedback(profileFeedbackSpan, "Error reading import file content.", 'red'); // <<< CORRECTED
                    return;
                }
                try {
                    const importedData = JSON.parse(fileContent);

                    // --- Validate Imported Profile Data Structure ---
                    let importedProfileName = importedData.profileName; // Expect profileName inside the JSON
                    if (!importedProfileName || typeof importedProfileName !== 'string') {
                        // Fallback: try to guess from filename if profileName isn't in the JSON
                        // This is less reliable and for older exports before profileName was included.
                        const nameMatch = file.name.match(/Profile_([^_\.]+)_settings/);
                        if (nameMatch && nameMatch[1]) {
                            importedProfileName = nameMatch[1].replace(/_/g, ' '); // Replace underscores with spaces
                            console.warn(`Imported file missing 'profileName' field. Guessed '${importedProfileName}' from filename.`);
                        } else {
                            importedProfileName = "Imported Profile " + new Date().toLocaleTimeString(); // Generic name
                            console.warn(`Imported file missing 'profileName' field. Using generic name: '${importedProfileName}'.`);
                        }
                        // Prompt user to confirm or change the guessed/generic name
                        const confirmedName = prompt(`Enter a name for the imported profile (detected/guessed as '${importedProfileName}'):`, importedProfileName);
                        if (!confirmedName || confirmedName.trim() === "") {
                            showFeedback(profileFeedbackSpan, "Import cancelled: Profile name not provided.", "orange"); // <<< CORRECTED
                            return;
                        }
                        importedProfileName = confirmedName.trim();
                    }

                    // Check for essential data keys (items, markup, pdfConfig, options, scopeTemplates)
                    const requiredKeys = ['items', 'markup', 'pdfConfig', 'proposalOptions', 'scopeTemplates'];
                    const missingKeys = requiredKeys.filter(key => !importedData.hasOwnProperty(key));
                    if (missingKeys.length > 0) {
                        throw new Error(`Invalid profile file format. Profile '${importedProfileName}' is missing required settings: ${missingKeys.join(', ')}.`);
                    }

                    // --- Handle Profile Name Conflict ---
                    if (profileNamesList.includes(importedProfileName)) {
                        if (!confirm(`A profile named '${importedProfileName}' already exists. Do you want to overwrite it?`)) {
                            showFeedback(profileFeedbackSpan, `Import of profile '${importedProfileName}' cancelled.`, "orange"); // <<< CORRECTED
                            return; // User chose not to overwrite
                        }
                        console.log(`Overwriting existing profile: ${importedProfileName}`);
                    } else {
                        // New profile name, add it to the list
                        profileNamesList.push(importedProfileName);
                        profileNamesList.sort();
                        saveProfileNamesToStorage(profileNamesList);
                        console.log(`Adding new profile to list: ${importedProfileName}`);
                    }

                    // --- Prepare and Save Profile Data ---
                    // Ensure all parts are present and use defaults for any missing sub-structures if necessary
                    const profileDataToSave = {
                        items: importedData.items || defaultItems.map(item => ({ pricingType: 'Fixed', formula: '', ...item })),
                        markup: (typeof importedData.markup === 'number') ? importedData.markup : defaultMarkup,
                        pdfConfig: { ...defaultPdfConfig, ...(importedData.pdfConfig || {}) },
                        options: importedData.proposalOptions || defaultProposalOptions.map(opt => ({ ...opt, id: opt.id || generateOptionId(), description: opt.description || "" })),
                        scopeTemplates: importedData.scopeTemplates || defaultScopeTemplates.map(tmpl => ({ ...tmpl, id: tmpl.id || generateScopeId() }))
                    };

                    localStorage.setItem(PROFILE_DATA_PREFIX + importedProfileName, JSON.stringify(profileDataToSave));

                    // --- Finalize Import ---
                    currentProfileName = importedProfileName; // Make the imported profile active
                    saveActiveProfileNameToStorage(currentProfileName);
                    loadAllSettings(currentProfileName); // Load and display the newly imported and active profile
                    populateProfileSelectDropdown(); // Ensure dropdown is updated and new profile selected
                    console.log(`IMPORT SUCCESS (AFTER ADDING LINE): Attempting to show feedback for '${importedProfileName}'. profileFeedbackSpan:`, profileFeedbackSpan);
                    showFeedback(profileFeedbackSpan, `Profile '${importedProfileName}' imported and loaded successfully!`, 'green');

                } catch (error) {
                    console.error("Error processing import file:", error);
                    showFeedback(profileFeedbackSpan, `Import failed: ${error.message}`, 'red', 0); // <<< CORRECTED
                    alert(`Import Error:\n${error.message}`);
                } finally {
                    if (event.target) event.target.value = null; // Clear file input
                }
            };
            reader.onerror = function (readError) {
                console.error("FileReader error:", readError);
                showFeedback(profileFeedbackSpan, `Error reading import file: ${readError.message || 'Unknown error'}`, 'red'); // <<< CORRECTED
                if (event.target) event.target.value = null;
            };
            reader.readAsText(file);
        }

        // === JS_BACKUP_RESTORE END ===

        // === JS_PDF_GENERATION START ===
        // --- PDF Generation Helper Functions ---
        function generatePdfFilename(docType) { // docType = "Internal", "Proposal", "Letterhead", "FieldQuote", "Subcontractor"
            const now = new Date();
            const dateStr = now.getFullYear().toString() +
                (now.getMonth() + 1).toString().padStart(2, '0') +
                now.getDate().toString().padStart(2, '0'); // YYYYMMDD

            const clientName = clientNameInput?.value || "NoClient";
            const projectName = projectInfoInput?.value || "NoProject";
            const sanitizedClient = sanitizeForFilename(clientName);
            const sanitizedProject = sanitizeForFilename(projectName);

            let baseName = `${dateStr}`;
            if (sanitizedClient && sanitizedClient !== "NoClient") { baseName += `_${sanitizedClient}`; }
            // Add project only if different from client or if client is empty
            if (sanitizedProject && sanitizedProject !== "NoProject" && sanitizedProject !== sanitizedClient) { baseName += `_${sanitizedProject}`; }
            else if (baseName === `${dateStr}` && sanitizedProject && sanitizedProject !== "NoProject") { baseName += `_${sanitizedProject}`; }
            baseName += `_${docType}`;

            return `${baseName.substring(0, 150)}.pdf`; // Limit overall length
        }

        /**
         * Draws the PDF header. Draws full header only on page 1 by default.
         * @param {jsPDF} doc - The jsPDF document instance.
         * @param {number} startY - The starting Y position.
         * @param {boolean} includeLogo - Whether to include the logo.
         * @param {boolean} includeDate - Whether to include the generation date.
         * @param {number} pageNum - The current page number (defaults to 1).
         * @returns {number} The Y position below the header (or startY if no header drawn).
         */
        function _drawPdfHeader(doc, startY, includeLogo = true, includeDate = true, pageNum = 1) {
            if (pageNum > 1) { return startY; }

            const leftMargin = 14;
            const rightMargin = doc.internal.pageSize.getWidth() - 14;
            const headerStartY = startY;
            let currentY = startY;
            let companyInfoX = leftMargin;
            let logoHeightUsed = 0;
            const logoDataUrl = currentPdfConfig?.logoDataUrl;
            // --- Store logo dimensions ---
            let logoW = 0;
            let logoH = 0;

            if (includeLogo && logoDataUrl && typeof logoDataUrl === 'string' && logoDataUrl.startsWith('data:image')) {
                try {
                    let format = 'JPEG'; if (logoDataUrl.startsWith('data:image/png')) { format = 'PNG'; }
                    const logoMaxHeight = 18; const logoMaxWidth = 60;
                    let w = logoMaxWidth; let h = logoMaxHeight; // Use let here
                    try {
                        const imgProps = doc.getImageProperties(logoDataUrl);
                        let ratio = imgProps.width / imgProps.height;
                        h = logoMaxHeight; w = h * ratio;
                        if (w > logoMaxWidth) { w = logoMaxWidth; h = w / ratio; }
                        if (h > logoMaxHeight) { h = logoMaxHeight; w = h * ratio; }
                    } catch (e) {
                        console.warn("Could not get image properties, using default size.", e);
                        w = Math.min(logoMaxWidth, 50); h = Math.min(logoMaxHeight, 15);
                    }
                    // --- Store final dimensions ---
                    logoW = w;
                    logoH = h;
                    doc.addImage(logoDataUrl, format, leftMargin, currentY, logoW, logoH);
                    companyInfoX = leftMargin + logoW + 5;
                    logoHeightUsed = logoH;

                    // --- ADD THE LINK ---
                    const websiteUrl = currentPdfConfig.companyWebsiteUrl;
                    if (websiteUrl && websiteUrl.trim() !== '') {
                        // Use the actual position and dimensions where the logo was drawn
                        try {
                            doc.link(leftMargin, currentY, logoW, logoH, { url: websiteUrl });
                        } catch (linkError) {
                            console.error("Error creating PDF link for logo:", linkError);
                        }
                    }
                    // --- END ADD LINK ---

                } catch (imgError) {
                    console.error("Error adding logo image to PDF:", imgError);
                    companyInfoX = leftMargin; logoHeightUsed = 0; logoW = 0; logoH = 0;
                }
            } else {
                companyInfoX = leftMargin; logoHeightUsed = 0; logoW = 0; logoH = 0;
            }

            // ... (rest of the header drawing logic for text remains the same) ...
            currentY = headerStartY;
            doc.setFontSize(16); doc.setFont(undefined, 'bold');
            const companyName = currentPdfConfig?.companyName || "Estimate/Proposal";
            doc.text(companyName, companyInfoX, currentY + 5);
            let textBottomY = currentY + 5 + (doc.getTextDimensions(companyName).h);
            doc.setFont(undefined, 'normal'); doc.setFontSize(10);
            if (includeDate) {
                const generationDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                doc.text(`Date: ${generationDate}`, rightMargin, currentY + 5, { align: 'right' });
                textBottomY = Math.max(textBottomY, currentY + 5 + (doc.getTextDimensions(generationDate).h));
            }
            currentY = textBottomY + 1;
            const textWrapWidth = rightMargin - companyInfoX;
            const addressString = String(currentPdfConfig?.companyAddress || '');
            const contactString = String(currentPdfConfig?.companyContact || '');
            if (addressString) { const addressLines = doc.splitTextToSize(addressString, textWrapWidth); doc.text(addressLines, companyInfoX, currentY); currentY += (addressLines.length * 4); }
            if (contactString) { const contactLines = doc.splitTextToSize(contactString, textWrapWidth); doc.text(contactLines, companyInfoX, currentY); currentY += (contactLines.length * 4); }
            textBottomY = currentY;
            let finalHeaderY = Math.max(headerStartY + logoHeightUsed, textBottomY);
            return finalHeaderY + 5;
        }

        /**
         * Draws the PDF footer, which now ONLY contains the page number.
         * @param {jsPDF} doc - The jsPDF document instance.
         * @param {number} pageNum - The current page number.
         * @param {string} titlePrefix - Prefix for the page number text (e.g., 'Proposal').
         * @returns {void}
         */
        function _drawPdfFooter(doc, pageNum, titlePrefix = '') {
            const pageCount = doc.internal.getNumberOfPages();
            const rightMargin = doc.internal.pageSize.getWidth() - 14;
            const bottomMargin = doc.internal.pageSize.getHeight() - 10;

            // Draw Page Number (always drawn)
            doc.setFontSize(9); doc.setTextColor(150); // Light grey for footer
            let text = `${titlePrefix ? titlePrefix + ' - ' : ''}Page ${pageNum} of ${pageCount}`;
            doc.text(text, rightMargin, bottomMargin, { align: 'right' });
            doc.setTextColor(0); // Reset text color
        }

        /**
         * Adds page number footers to all existing pages of a document.
         * @param {jsPDF} doc - The jsPDF document instance.
         * @param {string} titlePrefix - Prefix for the page number text.
         * @returns {void}
         */
        function _addFootersToAllPages(doc, titlePrefix = '') {
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i); // Go to page i
                _drawPdfFooter(doc, i, titlePrefix); // Add page number footer
            }
        }

        /**
          * Draws the Notes/Terms section in the main body. Handles page breaks.
          * @param {jsPDF} doc - The jsPDF document instance.
          * @param {number} startY - The Y position to start drawing from.
          * @param {string} docType - Type of document for header redraw on page break.
          * @returns {number} The Y position below the notes.
          */
        function _drawPdfNotesAndTerms(doc, startY, docType = 'Unknown') {
            let currentY = startY;
            const leftMargin = 14;
            const rightMargin = doc.internal.pageSize.getWidth() - 14;
            const contentWidth = rightMargin - leftMargin;
            const notesString = String(currentPdfConfig?.defaultNotes || '');

            if (notesString) {
                // Add some space before the notes section (Reduced)
                currentY += 5; // MODIFIED from 10

                // Page break check before drawing notes title
                if (currentY > doc.internal.pageSize.getHeight() - 30) { // Check space before title
                    doc.addPage();
                    const newPageNum = doc.internal.getNumberOfPages();
                    const includeDate = (docType === 'Proposal');
                    currentY = _drawPdfHeader(doc, 15, true, includeDate, newPageNum);
                    currentY += 5;
                }

                doc.setFontSize(9); doc.setFont(undefined, 'bold');
                doc.text("Notes / Terms:", leftMargin, currentY); currentY += 4;
                doc.setFontSize(8); doc.setFont(undefined, 'normal');

                const notesLines = doc.splitTextToSize(notesString, contentWidth);
                const lineHeight = 3.5; // Approx line height for font size 8

                notesLines.forEach(line => {
                    // Check if the next line fits on the current page
                    if (currentY + lineHeight > doc.internal.pageSize.getHeight() - 20) { // Check space before drawing line (leave footer margin)
                        doc.addPage();
                        const newPageNum = doc.internal.getNumberOfPages();
                        const includeDate = (docType === 'Proposal');
                        currentY = _drawPdfHeader(doc, 15, true, includeDate, newPageNum); // Draw header on new page
                        currentY += 5; // Space after header
                    }
                    doc.text(line, leftMargin, currentY);
                    currentY += lineHeight;
                });
                currentY += 2; // Add padding after the notes section (Reduced from 5)
            }
            return currentY;
        }


        /**
         * Draws signature lines on the PDF. Handles page breaks correctly before drawing.
         * @param {jsPDF} doc - The jsPDF document instance.
         * @param {number} startY - The Y position to start drawing from.
         * @param {string} docType - The type of document ('Proposal', 'Subcontractor', etc.) for header redraw.
         * @returns {number} The Y position below the signature lines.
         */
        function _drawPdfSignatureLines(doc, startY, docType = 'Unknown') {
            let currentY = startY;
            const leftMargin = 14;
            const signatureLineLength = 80;
            const dateLineLength = 40;
            const lineSpacing = 15;
            // Calculate space needed: one or two signature lines + buffer before footer
            const requiredSpace = (docType === 'Proposal' ? (lineSpacing * 2) : lineSpacing) + 30; // Space for lines + 30 unit buffer

            // Page break check: Does the required space fit before the bottom margin?
            if (currentY > doc.internal.pageSize.getHeight() - requiredSpace) {
                doc.addPage();
                const newPageNum = doc.internal.getNumberOfPages();
                const includeDateInHeader = (docType === 'Proposal');
                currentY = _drawPdfHeader(doc, 15, true, includeDateInHeader, newPageNum); // Draw header on new page
                currentY += 5; // MODIFIED: Reduced space after header on new page
            } else {
                currentY += 5; // Add space before signatures if not on new page (Reduced from 10)
            }

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');

            // Client Signature (Only for Proposal)
            if (docType === 'Proposal') {
                const clientSigX = leftMargin;
                doc.line(clientSigX, currentY, clientSigX + signatureLineLength, currentY);
                doc.text("Client Signature", clientSigX, currentY + 4);
                const clientDateX = clientSigX + signatureLineLength + 15;
                doc.line(clientDateX, currentY, clientDateX + dateLineLength, currentY);
                doc.text("Date", clientDateX, currentY + 4);
                currentY += lineSpacing;
            }

            // Company / Subcontractor Signature
            const sigX = leftMargin;
            doc.line(sigX, currentY, sigX + signatureLineLength, currentY);
            const signerLabel = (docType === 'Subcontractor') ? "Subcontractor Signature" : (currentPdfConfig?.companyName || "Company Representative");
            doc.text(signerLabel, sigX, currentY + 4);
            const dateX = sigX + signatureLineLength + 15;
            doc.line(dateX, currentY, dateX + dateLineLength, currentY);
            doc.text("Date", dateX, currentY + 4);

            return currentY + 5; // Return Y position below signature area (Reduced from 10)
        }


        function _drawPdfJobInfo(doc, startY, docType = 'Unknown') { // Used for Internal & Subcontractor PDF
            let currentY = startY; const leftMargin = 14;
            doc.setFontSize(11);
            doc.text(`Client: ${clientNameInput?.value || 'N/A'}`, leftMargin, currentY); currentY += 5;
            doc.text(`Project: ${projectInfoInput?.value || 'N/A'}`, leftMargin, currentY); currentY += 5;
            // Only show dimensions/calc on Internal PDF
            if (docType === 'Internal') {
                doc.text(`Area: ${jobAreaInput?.value || 'N/A'} sq ft`, leftMargin, currentY); currentY += 5;
                doc.text(`Thickness: ${jobThicknessInput?.value || 'N/A'} inches`, leftMargin, currentY); currentY += 5;
                doc.text(`Calculated Concrete: ${calculatedConcreteVolumeEl?.textContent || '~0.00 cu yd'}`, leftMargin, currentY); currentY += 5;
            }
            currentY += 5; // Add space after
            return currentY;
        }

        function _drawPdfProposalClientInfo(doc, startY) { // Used for Proposal & Field Quote PDF
            let currentY = startY; const leftMargin = 14; const rightMargin = doc.internal.pageSize.getWidth() - 14; const contentWidth = rightMargin - leftMargin;
            const clientName = clientNameInput?.value.trim() || "[Client Name]";
            const projectInfo = projectInfoInput?.value.trim() || "[Project Information]";
            doc.setFontSize(11); doc.setFont(undefined, 'bold'); doc.text("Proposal For:", leftMargin, currentY); currentY += 6;
            doc.setFont(undefined, 'normal');
            doc.text(clientName, leftMargin, currentY); currentY += 5;
            const projectLines = doc.splitTextToSize(projectInfo, contentWidth); doc.text(projectLines, leftMargin, currentY); currentY += (projectLines.length * 5) + 5; // Add space after
            return currentY;
        }

        function _drawPdfScopeOfWork(doc, startY, docType = 'Unknown') { // Used for multiple PDF types
            let currentY = startY; const leftMargin = 14; const rightMargin = doc.internal.pageSize.getWidth() - 14; const contentWidth = rightMargin - leftMargin;
            const scopeOfWork = scopeOfWorkInput?.value.trim() || '[Scope of Work not provided]';
            const pageNum = doc.internal.getNumberOfPages(); // Get current page number

            // Check for page break BEFORE drawing section
            if (currentY > 200) { // Threshold might need adjustment
                doc.addPage();
                const newPageNum = doc.internal.getNumberOfPages();
                // Redraw header appropriate for the document type, passing new page number
                const includeDateInHeader = (docType === 'Proposal' || docType === 'FieldQuote');
                currentY = _drawPdfHeader(doc, 15, true, includeDateInHeader, newPageNum); // Pass newPageNum
                // Note: Footer will be added by _addFootersToAllPages later
                currentY += 5; // Space after header
            }
            doc.setFontSize(11); doc.setFont(undefined, 'bold'); doc.text("Scope of Work:", leftMargin, currentY); currentY += 6;
            doc.setFontSize(10); doc.setFont(undefined, 'normal');
            const scopeLines = doc.splitTextToSize(scopeOfWork, contentWidth);
            doc.text(scopeLines, leftMargin, currentY);
            currentY += (scopeLines.length * 5) + 5; // MODIFIED: Reduced padding from 10 to 5
            return currentY;
        }

        function _drawPdfItemsTableInternal(doc, startY, estimateItems) {
            let currentY = startY; const leftMargin = 14; const rightMargin = doc.internal.pageSize.getWidth() - 14; const contentWidth = rightMargin - leftMargin;
            const hasAutoTable = typeof doc.autoTable === 'function';

            if (estimateItems.length === 0) {
                doc.setFontSize(10); doc.text("No items with quantity entered for this estimate.", leftMargin, currentY);
                return currentY + 10;
            }

            if (hasAutoTable) {
                const head = [['Item', 'Qty', 'Unit', 'Cost/Unit', 'Total']];
                const body = estimateItems.map(item => [
                    { content: `${item.name}${item.description ? `\n(${item.description})` : ''}`, styles: { fontSize: 8.5, cellPadding: 1, valign: 'top' } }, // valign top for multi-line item name
                    { content: item.quantity.toString(), styles: { halign: 'right' } },
                    { content: item.unit, styles: { halign: 'center' } },
                    { content: item.pricingType === 'Formula' ? '(Formula)' : formatCurrency(item.cost), styles: { halign: 'right' } },
                    { content: formatCurrency(item.total), styles: { halign: 'right' } }
                ]);
                doc.autoTable({
                    startY: currentY,
                    head: head,
                    body: body,
                    theme: 'grid',
                    headStyles: { fillColor: [220, 220, 220], textColor: 0, fontStyle: 'bold', halign: 'center' },
                    styles: { fontSize: 9, cellPadding: 1.5, valign: 'middle' }, // Default valign middle
                    columnStyles: {
                        0: { cellWidth: 'auto', minCellWidth: 60 }, // Item Name/Desc
                        1: { cellWidth: 15, halign: 'right' },      // Qty
                        2: { cellWidth: 15, halign: 'center' },     // Unit
                        3: { cellWidth: 25, halign: 'right' },      // Cost/Unit
                        4: { cellWidth: 25, halign: 'right' }       // Total
                    },
                    didDrawPage: (data) => {
                        // AutoTable handles adding pages, just need to add footer
                        _drawPdfFooter(doc, data.pageNumber, 'Internal Estimate'); // Footer only has page number now
                    }
                });
                currentY = doc.autoTable.previous.finalY + 10; // Y position after the table
            } else {
                // Fallback basic text layout (no AutoTable)
                console.warn("jsPDF-AutoTable plugin not found. Using basic text layout for items table.");
                doc.setFontSize(11); doc.setFont(undefined, 'bold');
                doc.text("Item", leftMargin, currentY);
                doc.text("Qty", 100, currentY, { align: 'right' });
                doc.text("Unit", 120, currentY);
                doc.text("Cost/Unit", 155, currentY, { align: 'right' });
                doc.text("Total", rightMargin, currentY, { align: 'right' });
                doc.setFont(undefined, 'normal'); currentY += 6;
                doc.setFontSize(9);
                estimateItems.forEach(item => {
                    // Manual Page Break Check
                    if (currentY > 270) { doc.addPage(); currentY = 20; _drawPdfFooter(doc, doc.internal.getNumberOfPages(), 'Internal Estimate'); }
                    const itemYStart = currentY;
                    const nameLines = doc.splitTextToSize(item.name, 80);
                    doc.text(nameLines, leftMargin, currentY);
                    doc.text(item.quantity.toString(), 100, itemYStart, { align: 'right' });
                    doc.text(item.unit, 120, itemYStart);
                    doc.text(item.pricingType === 'Formula' ? '(Formula)' : formatCurrency(item.cost), 155, itemYStart, { align: 'right' });
                    doc.text(formatCurrency(item.total), rightMargin, itemYStart, { align: 'right' });
                    let itemBlockHeight = nameLines.length * 4; // Height of the name block
                    // Add description below name if present
                    if (item.description) {
                        currentY += itemBlockHeight + 1; // Move below name
                        doc.setFontSize(8); doc.setTextColor(100);
                        const descLines = doc.splitTextToSize(`(${item.description})`, contentWidth - 5); // Indent description slightly
                        doc.text(descLines, leftMargin + 2, currentY);
                        itemBlockHeight += descLines.length * 3.5 + 1; // Add description height
                        doc.setTextColor(0); doc.setFontSize(9); // Reset font
                    }
                    // Ensure currentY moves past the entire block, plus padding
                    currentY = itemYStart + Math.max(itemBlockHeight, 6) + 2; // Ensure min height + padding
                });
                currentY += 5; // Padding after last item
            }
            return currentY;
        }

        // Draws selected Adjustments (marked "Show on Quote?") for Proposal/FieldQuote PDF
        function _drawPdfOptions(doc, startY, appliedAdjustmentsList, docType = 'Unknown') {
            let currentY = startY; const leftMargin = 14; const rightMargin = doc.internal.pageSize.getWidth() - 14; const contentWidth = rightMargin - leftMargin;
            const pageNum = doc.internal.getNumberOfPages(); // Get current page number

            if (appliedAdjustmentsList.length > 0) {
                // Page break check BEFORE drawing section
                if (currentY > 240) {
                    doc.addPage();
                    const newPageNum = doc.internal.getNumberOfPages();
                    currentY = _drawPdfHeader(doc, 15, true, true, newPageNum); // Assume full header needed if breaking here (pass page num)
                    currentY += 5;
                    // Note: Footer added later
                }
                doc.setFontSize(11); doc.setFont(undefined, 'bold'); doc.text("Selected Adjustments:", leftMargin, currentY); currentY += 6;
                doc.setFont(undefined, 'normal');
                appliedAdjustmentsList.forEach(opt => {
                    // Page break check WITHIN loop
                    if (currentY > 265) {
                        doc.addPage();
                        const newPageNum = doc.internal.getNumberOfPages();
                        currentY = _drawPdfHeader(doc, 15, true, true, newPageNum); // Pass new page num
                        currentY += 5;
                        // Note: Footer added later
                    }
                    doc.setFontSize(10);
                    doc.text(`${String(opt.name || 'Adjustment')}:`, leftMargin, currentY);
                    doc.text(formatCurrency(opt.amount), rightMargin, currentY, { align: 'right' });
                    currentY += 4; // Move down for description
                    // Add description if exists
                    if (opt.description) {
                        doc.setFontSize(8); doc.setTextColor(100); // Smaller, grey font for description
                        const descLines = doc.splitTextToSize(String(opt.description), contentWidth - 5); // Indent description
                        doc.text(descLines, leftMargin + 3, currentY);
                        currentY += descLines.length * 3.5; // Adjust Y for description lines
                        doc.setTextColor(0); // Reset color
                    }
                    currentY += 2; // Padding between options
                });
                currentY += 2; // MODIFIED: Reduced padding from 5 to 2
            }
            return currentY;
        }

        /**
         * Draws the totals section for the Internal PDF.
         * Displays a detailed list of ALL selected options/adjustments passed to it.
         * Shows the final calculated grand total (Base + Markup + Adjustments only).
         * @param {jsPDF} doc - The jsPDF document instance.
         * @param {number} startY - The starting Y position.
         * @param {object} baseEstimate - Result from calculateBaseEstimate().
         * @param {object} finalTotals - Result from calculateOptionsAndFinalTotal() (used for the final total number).
         * @param {Array<object>} allSelectedOptionsList - The comprehensive list from _getAllSelectedOptionsDataForInternal().
         * @returns {number} The Y position after drawing.
         */
        function _drawPdfTotalsInternal(doc, startY, baseEstimate, finalTotals, allSelectedOptionsList) {
            let currentY = startY; const totalLabelX = 140; const totalValueX = doc.internal.pageSize.getWidth() - 14;
            const pageNum = doc.internal.getNumberOfPages(); // Get current page number

            // Handle page break before totals section
            if (currentY > 220) { // Adjust threshold if needed based on typical item table length
                doc.addPage();
                const newPageNum = doc.internal.getNumberOfPages();
                currentY = _drawPdfHeader(doc, 15, true, false, newPageNum); // Internal header (no date), pass page num
                currentY += 5;
                _drawPdfFooter(doc, newPageNum, 'Internal Estimate'); // Add footer immediately
            }

            // Draw Subtotal, Markup, Total Before Adjustments (these are standard)
            doc.setFontSize(11); doc.setFont(undefined, 'normal');
            doc.text("Subtotal:", totalLabelX, currentY, { align: 'right' }); doc.text(formatCurrency(baseEstimate.subtotal), totalValueX, currentY, { align: 'right' }); currentY += 6;
            doc.text(`Markup (${parseFloat(baseEstimate.markupPercent).toFixed(1)}%):`, totalLabelX, currentY, { align: 'right' }); doc.text(formatCurrency(baseEstimate.markupAmount), totalValueX, currentY, { align: 'right' }); currentY += 6;
            doc.setFont(undefined, 'bold');
            doc.text("Total Before Adjustments:", totalLabelX, currentY, { align: 'right' }); doc.text(formatCurrency(baseEstimate.totalBeforeOptions), totalValueX, currentY, { align: 'right' }); currentY += 6;
            doc.setFont(undefined, 'normal');

            // --- Display ALL selected items (Adjustments and Optionals) from the passed list ---
            if (allSelectedOptionsList && allSelectedOptionsList.length > 0) {
                doc.setLineDashPattern([1, 1], 0); doc.line(totalLabelX - 50, currentY, totalValueX, currentY); doc.setLineDashPattern([]); currentY += 5;
                // Add a small title for this section
                doc.setFontSize(9); doc.setFont(undefined, 'bold'); doc.text("Applied Adjustments & Selected Options:", totalLabelX - 50, currentY); currentY += 4;
                doc.setFont(undefined, 'normal'); doc.setFontSize(10);
                // Loop through the comprehensive list passed to the function
                allSelectedOptionsList.forEach(opt => {
                    // Check for page break within the list drawing loop
                    if (currentY > 270) {
                        doc.addPage();
                        const newPageNum = doc.internal.getNumberOfPages();
                        currentY = _drawPdfHeader(doc, 15, true, false, newPageNum); currentY += 5; // Pass page num
                        // Optionally redraw header for this section on new page
                        doc.setFontSize(9); doc.setFont(undefined, 'bold'); doc.text("Applied Adjustments & Selected Options (Cont.):", totalLabelX - 50, currentY); currentY += 4;
                        doc.setFontSize(10); doc.setFont(undefined, 'normal');
                        _drawPdfFooter(doc, newPageNum, 'Internal Estimate');
                    }
                    // Add '(Optional)' label if the flag is set
                    const nameLabel = `${String(opt.name || 'Item')}${opt.isOptional ? ' (Optional)' : ''}`;
                    doc.text(`${nameLabel}:`, totalLabelX, currentY, { align: 'right' });
                    doc.text(formatCurrency(opt.amount), totalValueX, currentY, { align: 'right' });
                    currentY += 5; // Spacing between items
                });
                doc.setLineDashPattern([1, 1], 0); doc.line(totalLabelX - 30, currentY, totalValueX, currentY); doc.setLineDashPattern([]); currentY += 6; // Space after list
            } else {
                // No options/adjustments selected at all
                currentY += 2; // Minimal space if nothing to list
            }
            // --- End of displaying all selected items ---

            // Draw the Final Total - Use finalTotals.grandTotal (Base + Markup + ADJUSTMENTS only)
            doc.setFontSize(12); doc.setFont(undefined, 'bold');
            doc.text("Final Total:", totalLabelX, currentY, { align: 'right' });
            doc.text(formatCurrency(finalTotals.grandTotal), totalValueX, currentY, { align: 'right' });
            doc.setFont(undefined, 'normal');
            currentY += 10; // Space after final total

            return currentY;
        }


        // Draws the main project total on the proposal/field quote (Base + Markup + Adjustments)
        function _drawPdfPriceProposal(doc, startY, grandTotal) {
            let currentY = startY; const leftMargin = 14; const rightMargin = doc.internal.pageSize.getWidth() - 14;
            const pageNum = doc.internal.getNumberOfPages(); // Get current page number
            // Page break check before drawing
            if (currentY > 260) {
                doc.addPage();
                const newPageNum = doc.internal.getNumberOfPages();
                currentY = _drawPdfHeader(doc, 15, true, true, newPageNum); // Assume full header needed, pass page num
                currentY += 5;
                // Footer added later
            }
            doc.setFontSize(12); doc.setFont(undefined, 'bold');
            doc.text("Total Project Investment:", leftMargin, currentY);
            doc.text(formatCurrency(grandTotal), rightMargin, currentY, { align: 'right' });
            currentY += 8; // MODIFIED: Reduced padding from 15 to 8
            return currentY;
        }

        /**
         * Draws the scratchpad notes on the Internal PDF.
         * @param {jsPDF} doc - The jsPDF document instance.
         * @param {number} startY - The starting Y position.
         * @returns {number} The Y position after drawing.
         */
        function _drawPdfScratchpadNotes(doc, startY) {
            let currentY = startY;
            const leftMargin = 14;
            const rightMargin = doc.internal.pageSize.getWidth() - 14;
            const contentWidth = rightMargin - leftMargin;
            const notes = dashboardScratchpad?.value.trim() || '';
            const pageNum = doc.internal.getNumberOfPages(); // Get current page number

            if (notes) {
                // Page break check before drawing
                if (currentY > 250) {
                    doc.addPage();
                    const newPageNum = doc.internal.getNumberOfPages();
                    currentY = _drawPdfHeader(doc, 15, true, false, newPageNum); // Internal header, pass page num
                    currentY += 5;
                    _drawPdfFooter(doc, newPageNum, 'Internal Estimate');
                }
                doc.setFontSize(10); doc.setFont(undefined, 'bold');
                doc.text("Internal Scratchpad Notes:", leftMargin, currentY); currentY += 5;
                doc.setFontSize(9); doc.setFont(undefined, 'normal');
                const notesLines = doc.splitTextToSize(notes, contentWidth);
                doc.text(notesLines, leftMargin, currentY);
                currentY += (notesLines.length * 4) + 10; // Space after notes
            }
            return currentY;
        }

        function _drawPdfProfitMetrics(doc, startY, baseEstimate, finalTotals) { // Used for Internal PDF
            let currentY = startY; const leftMargin = 14;
            const pageNum = doc.internal.getNumberOfPages(); // Get current page number
            // Page break check
            if (currentY > 265) {
                doc.addPage();
                const newPageNum = doc.internal.getNumberOfPages();
                currentY = _drawPdfHeader(doc, 15, true, false, newPageNum); // Internal header, pass page num
                currentY += 5;
                _drawPdfFooter(doc, newPageNum, 'Internal Estimate');
            }
            const franchiseFee = finalTotals.grandTotal * 0.08;
            const profitAfterFee = baseEstimate.markupAmount - franchiseFee;
            const sqft = parseFloat(jobAreaInput?.value) || 0;
            const pricePerSqft = sqft > 0 ? finalTotals.grandTotal / sqft : 0;
            doc.setFontSize(9); doc.setTextColor(100); // Grey text for internal metrics
            doc.text(`Est. Franchise Fee (8%): ${formatCurrency(franchiseFee)}`, leftMargin, currentY); currentY += 4;
            doc.text(`Est. Profit After Fee: ${formatCurrency(profitAfterFee)}`, leftMargin, currentY); currentY += 4;
            doc.text(`Price Per Sq Ft: ${formatCurrency(pricePerSqft)}`, leftMargin, currentY);
            doc.setTextColor(0); // Reset text color
            return currentY + 4; // Return Y position after drawing
        }


        /** Draws the "Optional Additions" section on the Proposal/FieldQuote PDF */
        function _drawPdfOptionalAdditions(doc, startY, optionalAdditionsList, docType = 'Unknown') {
            let currentY = startY; const leftMargin = 14; const rightMargin = doc.internal.pageSize.getWidth() - 14; const contentWidth = rightMargin - leftMargin;
            // Filter list to only those marked "Show on Quote?" on the dashboard
            const optionsToShow = optionalAdditionsList.filter(opt => opt.showOnQuote);
            const pageNum = doc.internal.getNumberOfPages(); // Get current page number

            if (optionsToShow.length > 0) {
                // Page break check BEFORE section
                if (currentY > 235) {
                    doc.addPage();
                    const newPageNum = doc.internal.getNumberOfPages();
                    currentY = _drawPdfHeader(doc, 15, true, true, newPageNum); // Assume full header needed, pass page num
                    // Footer added later
                    currentY += 5;
                }
                currentY += 8; // MODIFIED: Reduced space before section title from 12 to 8
                doc.setFontSize(11); doc.setFont(undefined, 'bold'); doc.text("Optional Additions (Not Included Above):", leftMargin, currentY); currentY += 6;
                doc.setFont(undefined, 'normal');

                optionsToShow.forEach(opt => {
                    // Page break check WITHIN loop
                    if (currentY > 265) {
                        doc.addPage();
                        const newPageNum = doc.internal.getNumberOfPages();
                        currentY = _drawPdfHeader(doc, 15, true, true, newPageNum); // Pass page num
                        // Footer added later
                        currentY += 5;
                    }
                    doc.setFontSize(10);
                    doc.text(`${String(opt.name || 'Optional Addition')}:`, leftMargin, currentY);
                    doc.text(formatCurrency(opt.amount), rightMargin, currentY, { align: 'right' });
                    currentY += 4; // Move down for description
                    // Add description if exists
                    if (opt.description) {
                        doc.setFontSize(8); doc.setTextColor(100); // Smaller, grey font
                        const descLines = doc.splitTextToSize(String(opt.description), contentWidth - 5); // Indent
                        doc.text(descLines, leftMargin + 3, currentY);
                        currentY += descLines.length * 3.5; // Adjust Y
                        doc.setTextColor(0); // Reset color
                    }
                    currentY += 3; // Padding between options
                });
                currentY += 2; // MODIFIED: Reduced padding after the last option from 5 to 2
            }
            return currentY; // Return the final Y position
        }

        /**
         * Draws the cost items table for the Subcontractor PDF.
         * Shows Name, Qty, Unit, Cost/Unit, and calculated BASE COST.
         * @param {jsPDF} doc - The jsPDF document instance.
         * @param {number} startY - The starting Y position.
         * @param {Array<object>} estimateItems - Array of items with qty > 0.
         * Each item in this array should ideally have:
         * { name, description, unit, quantity, cost, pricingType, (optional: formula if pricingType is 'Formula') }
         * @returns {number} The Y position after drawing the table.
         */
        function _drawPdfItemsTableSubcontractor(doc, startY, estimateItems) {
            let currentY = startY;
            const leftMargin = 14;
            const rightMargin = doc.internal.pageSize.getWidth() - 14;
            const contentWidth = rightMargin - leftMargin;
            const hasAutoTable = typeof doc.autoTable === 'function';

            if (estimateItems.length === 0) {
                doc.setFontSize(10);
                doc.text("No items with quantity entered for this estimate.", leftMargin, currentY);
                return currentY + 10;
            }

            let grandTotalBaseCost = 0;

            // Get context variables once for all formula evaluations
            const currentJobArea = parseFloat(jobAreaInput?.value) || 0;
            const currentJobThickness = parseFloat(jobThicknessInput?.value) || 0;

            // Helper function for formula evaluation.
            // Returns the calculated value and a string for display (e.g., "$123.45" or "(Formula)").
            function evaluateFormulaValueAndDisplay(itemDef, itemQuantity, jobArea, jobThickness) {
                let calculatedValue = 0;
                let displayValue = '(Formula)'; // Default display for formula type

                if (itemDef && itemDef.formula) { // Ensure formula string exists in the item definition
                    try {
                        const formulaContext = { quantity: itemQuantity, jobArea: jobArea, jobThickness: jobThickness };
                        const formulaFunc = new Function(...Object.keys(formulaContext), `return ${itemDef.formula}`);
                        const result = formulaFunc(...Object.values(formulaContext));

                        if (typeof result === 'number' && !isNaN(result) && isFinite(result)) {
                            calculatedValue = result;
                            displayValue = formatCurrency(calculatedValue); // For the total column
                        } else {
                            console.warn(`[SubPDF Formula Eval Helper] Formula for '${itemDef.name}' resulted in invalid number: ${result}. Formula: ${itemDef.formula}`);
                            displayValue = '(Calc Error)';
                        }
                    } catch (e) {
                        console.error(`[SubPDF Formula Eval Helper] Error evaluating formula for '${itemDef.name}': Formula="${itemDef.formula}"`, e);
                        displayValue = '(Formula Error)';
                    }
                } else {
                    console.warn(`[SubPDF Formula Eval Helper] Item '${itemDef?.name}' is marked 'Formula' but missing formula string or definition for evaluation.`);
                    displayValue = '(No Formula String)';
                }
                return { calculatedValue, displayValue };
            }


            if (hasAutoTable) {
                console.log("[_drawPdfItemsTableSubcontractor] Using jsPDF-AutoTable path.");
                const head = [['Item', 'Qty', 'Unit', 'Cost/Unit', 'Total (Base)']];
                const body = estimateItems.map(item => {
                    console.log("[SubPDF map - AutoTable] Processing item:", JSON.stringify(item));

                    let lineTotalBase = 0;
                    let costPerUnitDisplay = '';
                    let totalDisplay = '';

                    if (item.pricingType === 'Formula') {
                        // For 'Formula' items, we need to get the original item definition to access its formula string.
                        // This applies only to permanent items, as temp items are always 'Fixed'.
                        const originalItemDef = currentItems.find(ci => ci.name === item.name && ci.pricingType === 'Formula');

                        if (originalItemDef) {
                            const evalResult = evaluateFormulaValueAndDisplay(originalItemDef, item.quantity, currentJobArea, currentJobThickness);
                            lineTotalBase = evalResult.calculatedValue;
                            costPerUnitDisplay = '(Formula)'; // For Cost/Unit column
                            totalDisplay = evalResult.displayValue; // For Total (Base) column
                        } else {
                            // This case should ideally not happen if 'estimateItems' is correctly pre-populated.
                            console.warn(`[SubPDF map - AutoTable] Original formula item definition not found for '${item.name}' during recalculation.`, item);
                            lineTotalBase = 0;
                            costPerUnitDisplay = '(N/A)';
                            totalDisplay = formatCurrency(0);
                        }

                    } else { // Handles 'Fixed' permanent items AND all temporary items
                        const itemCost = parseFloat(item.cost) || 0; // Trust the 'cost' property already on the item object in 'estimateItems'
                        lineTotalBase = (parseFloat(item.quantity) || 0) * itemCost;
                        costPerUnitDisplay = formatCurrency(itemCost); // Display the actual cost/unit
                        totalDisplay = formatCurrency(lineTotalBase); // Display the calculated total
                    }
                    grandTotalBaseCost += lineTotalBase;
                    console.log(`[SubPDF map - AutoTable] For item '${item.name}', Cost/Unit: '${costPerUnitDisplay}', Total: '${totalDisplay}', lineTotalBase: ${lineTotalBase}`);

                    return [
                        { content: `${item.name}${item.description ? `\n(${item.description})` : ''}`, styles: { fontSize: 8.5, cellPadding: 1, valign: 'top' } },
                        { content: (parseFloat(item.quantity) || 0).toString(), styles: { halign: 'right' } },
                        { content: item.unit, styles: { halign: 'center' } },
                        { content: costPerUnitDisplay, styles: { halign: 'right' } },
                        { content: totalDisplay, styles: { halign: 'right' } }
                    ];
                });

                doc.autoTable({
                    startY: currentY,
                    head: head,
                    body: body,
                    theme: 'grid',
                    headStyles: { fillColor: [220, 220, 220], textColor: 0, fontStyle: 'bold', halign: 'center' },
                    styles: { fontSize: 9, cellPadding: 1.5, valign: 'middle' },
                    columnStyles: {
                        0: { cellWidth: 'auto', minCellWidth: 60 },
                        1: { cellWidth: 15, halign: 'right' },
                        2: { cellWidth: 15, halign: 'center' },
                        3: { cellWidth: 25, halign: 'right' },
                        4: { cellWidth: 25, halign: 'right' }
                    },
                    didDrawPage: (data) => {
                        _drawPdfFooter(doc, data.pageNumber, 'Subcontractor Details');
                    }
                });
                currentY = doc.autoTable.previous.finalY + 5;

            } else { // Fallback for no AutoTable
                console.warn("[_drawPdfItemsTableSubcontractor] jsPDF-AutoTable plugin not found. Using basic text layout.");
                doc.setFontSize(11); doc.setFont(undefined, 'bold');
                doc.text("Item", leftMargin, currentY);
                doc.text("Qty", leftMargin + 80, currentY, { align: 'right' });
                doc.text("Unit", leftMargin + 95, currentY);
                doc.text("Cost/Unit", leftMargin + 125, currentY, { align: 'right' });
                doc.text("Total (Base)", rightMargin, currentY, { align: 'right' });
                doc.setFont(undefined, 'normal'); currentY += 7;
                doc.setFontSize(9);

                estimateItems.forEach(item => {
                    console.log("[SubPDF forEach - Fallback] Processing item:", JSON.stringify(item));
                    if (currentY > doc.internal.pageSize.getHeight() - 40) {
                        doc.addPage();
                        currentY = _drawPdfHeader(doc, 15, true, false, doc.internal.getNumberOfPages());
                        currentY += 5;
                        _drawPdfFooter(doc, doc.internal.getNumberOfPages(), 'Subcontractor Details');
                        doc.setFontSize(11); doc.setFont(undefined, 'bold');
                        doc.text("Item", leftMargin, currentY);
                        doc.text("Qty", leftMargin + 80, currentY, { align: 'right' });
                        doc.text("Unit", leftMargin + 95, currentY);
                        doc.text("Cost/Unit", leftMargin + 125, currentY, { align: 'right' });
                        doc.text("Total (Base)", rightMargin, currentY, { align: 'right' });
                        doc.setFont(undefined, 'normal'); currentY += 7;
                        doc.setFontSize(9);
                    }
                    const itemYStart = currentY;
                    const nameLines = doc.splitTextToSize(item.name, 75);
                    doc.text(nameLines, leftMargin, currentY);

                    const itemQuantityStr = (parseFloat(item.quantity) || 0).toString();
                    doc.text(itemQuantityStr, leftMargin + 80, itemYStart, { align: 'right' });
                    doc.text(item.unit, leftMargin + 95, itemYStart);

                    let lineTotalBase = 0;
                    let costPerUnitDisplay = '';
                    let totalDisplay = '';

                    if (item.pricingType === 'Formula') {
                        const originalItemDef = currentItems.find(ci => ci.name === item.name && ci.pricingType === 'Formula');
                        if (originalItemDef) {
                            const evalResult = evaluateFormulaValueAndDisplay(originalItemDef, item.quantity, currentJobArea, currentJobThickness);
                            lineTotalBase = evalResult.calculatedValue;
                            costPerUnitDisplay = '(Formula)';
                            totalDisplay = evalResult.displayValue;
                        } else {
                            console.warn(`[SubPDF forEach - Fallback] Original formula item definition not found for '${item.name}' during recalculation.`, item);
                            lineTotalBase = 0;
                            costPerUnitDisplay = '(N/A)';
                            totalDisplay = formatCurrency(0);
                        }
                    } else {
                        const itemCost = parseFloat(item.cost) || 0;
                        lineTotalBase = (parseFloat(item.quantity) || 0) * itemCost;
                        costPerUnitDisplay = formatCurrency(itemCost);
                        totalDisplay = formatCurrency(lineTotalBase);
                    }
                    grandTotalBaseCost += lineTotalBase;
                    console.log(`[SubPDF forEach - Fallback] For item '${item.name}', Cost/Unit: '${costPerUnitDisplay}', Total: '${totalDisplay}', lineTotalBase: ${lineTotalBase}`);

                    doc.text(costPerUnitDisplay, leftMargin + 125, itemYStart, { align: 'right' });
                    doc.text(totalDisplay, rightMargin, itemYStart, { align: 'right' });

                    let itemBlockHeight = nameLines.length * 4;
                    const minLineHeight = 5;

                    if (item.description) {
                        const descY = itemYStart + itemBlockHeight + 1;
                        doc.setFontSize(8); doc.setTextColor(100);
                        const descLines = doc.splitTextToSize(`(${item.description})`, 75);
                        doc.text(descLines, leftMargin + 2, descY);
                        itemBlockHeight += (descLines.length * 3.5) + 1;
                        doc.setTextColor(0); doc.setFontSize(9);
                    }
                    currentY = itemYStart + Math.max(itemBlockHeight, minLineHeight) + 3;
                });
                currentY += 5;
            }

            // --- Draw the Grand Total Base Cost ---
            currentY += 5;
            if (currentY > doc.internal.pageSize.getHeight() - 30) {
                doc.addPage();
                currentY = _drawPdfHeader(doc, 15, true, false, doc.internal.getNumberOfPages());
                currentY += 5;
                _drawPdfFooter(doc, doc.internal.getNumberOfPages(), 'Subcontractor Details');
            }
            doc.setFontSize(11);
            doc.setFont(undefined, 'bold');
            const totalLabelX = rightMargin - 60;
            doc.text("Total Base Estimate:", totalLabelX, currentY, { align: 'left' });
            doc.text(formatCurrency(grandTotalBaseCost), rightMargin, currentY, { align: 'right' });
            currentY += 10;

            return currentY;
        }

        /**
         * Draws a decorative horizontal line.
         * @param {jsPDF} doc - The jsPDF document instance.
         * @param {number} y - The Y position for the line.
         * @param {string} color - The hex color for the line.
         * @param {number} thickness - The thickness of the line.
         */
        function _drawHorizontalLine(doc, y, color, thickness = 0.5) {
            const leftMargin = 14;
            const rightMargin = doc.internal.pageSize.getWidth() - 14;
            doc.setDrawColor(color);
            doc.setLineWidth(thickness);
            doc.line(leftMargin, y, rightMargin, y);
            doc.setDrawColor(0); // Reset draw color
            doc.setLineWidth(0.2); // Reset line width
        }


        // --- Main PDF Generation Functions ---

        function generateInternalPDF() {
            const doc = getJsPDF(); if (!doc) return;
            const feedbackEl = internalPdfFeedback;
            showFeedback(feedbackEl, `Generating...`, 'orange', 0);

            // --- Data Calculation ---
            const baseEstimate = calculateBaseEstimate();
            const calculationResults = calculateOptionsAndFinalTotal(baseEstimate); // Get comprehensive calculation results
            const allSelectedOptionsForInternalList = _getAllSelectedOptionsDataForInternal(calculationResults.grandTotal, baseEstimate); // Pass final total and base estimate
            const scratchpadNotes = dashboardScratchpad?.value.trim() || '';

            // Gather line items with quantities > 0
            const estimateItems = [];
            const currentJobArea = parseFloat(jobAreaInput?.value) || 0;
            const currentJobThickness = parseFloat(jobThicknessInput?.value) || 0;

            // Add PERMANENT items
            const quantityInputs = dashboardItemsDiv ? dashboardItemsDiv.querySelectorAll('.dashboard-quantity') : [];
            quantityInputs.forEach(input => {
                const quantity = parseFloat(input.value) || 0;
                if (quantity > 0) {
                    const itemIndex = parseInt(input.getAttribute('data-item-index'), 10);
                    if (!isNaN(itemIndex) && Array.isArray(currentItems) && itemIndex >= 0 && itemIndex < currentItems.length) {
                        const item = currentItems[itemIndex];
                        let itemTotal = 0;
                        let itemCostForDisplay = item.cost; // Default cost for fixed items

                        if (item.pricingType === 'Formula' && item.formula) {
                            try {
                                const formulaContext = { quantity: quantity, jobArea: currentJobArea, jobThickness: currentJobThickness };
                                const formulaFunc = new Function(...Object.keys(formulaContext), `return ${item.formula}`);
                                itemTotal = formulaFunc(...Object.values(formulaContext));
                                if (isNaN(itemTotal) || !isFinite(itemTotal)) itemTotal = 0;
                                itemCostForDisplay = 0; // Don't show unit cost for formula items, indicate it's formula-based
                            } catch (e) {
                                itemTotal = 0;
                                itemCostForDisplay = '(Error)'; // Indicate formula error
                                console.error(`Error calculating PDF item total for '${item.name}':`, e);
                            }
                        } else { // Fixed pricing
                            itemCostForDisplay = parseFloat(item?.cost) || 0;
                            itemTotal = quantity * itemCostForDisplay;
                        }

                        estimateItems.push({
                            name: String(item?.name || ''),
                            description: String(item?.description || ''),
                            unit: String(item?.unit || ''),
                            quantity: quantity,
                            cost: itemCostForDisplay,
                            total: itemTotal,
                            pricingType: item.pricingType // Keep pricingType for display logic in table drawing
                        });
                    }
                }
            });

            // Add TEMPORARY cost items
            const tempItemContainers = dashboardTempItemsDiv ? dashboardTempItemsDiv.querySelectorAll('.dashboard-item-container[data-temp-item-id]') : [];
            tempItemContainers.forEach(container => {
                const quantityInput = container.querySelector('.temp-item-quantity');
                const costInput = container.querySelector('.temp-item-cost');
                const nameInput = container.querySelector('.temp-item-name');
                const descInput = container.querySelector('.temp-item-description');

                const quantity = parseFloat(quantityInput?.value) || 0;
                const cost = parseFloat(costInput?.value) || 0;
                const name = nameInput?.value.trim() || 'Unnamed Temporary Item';
                const description = descInput?.value.trim() || '';

                if (quantity > 0) {
                    const itemTotal = quantity * cost;
                    estimateItems.push({
                        name: name,
                        description: description,
                        unit: 'each',
                        quantity: quantity,
                        cost: cost,
                        total: itemTotal,
                        pricingType: 'Fixed'
                    });
                }
            });


            // Use setTimeout to allow UI feedback to render before potential blocking PDF generation
            setTimeout(() => {
                try {
                    let currentY = 15;
                    const docType = 'Internal'; // Define docType for helpers

                    // --- PDF Drawing ---
                    currentY = _drawPdfHeader(doc, currentY, true, false, 1);
                    doc.setFontSize(10);
                    doc.setFont(undefined, 'bold');
                    doc.text(`INTERNAL ESTIMATE DETAIL`, 14, currentY);
                    doc.setFont(undefined, 'normal');
                    currentY += 10;
                    currentY = _drawPdfJobInfo(doc, currentY, docType);
                    currentY = _drawPdfItemsTableInternal(doc, currentY, estimateItems);
                    // Pass the full calculationResults object to _drawPdfTotalsInternal
                    currentY = _drawPdfTotalsInternal(doc, currentY, baseEstimate, calculationResults, allSelectedOptionsForInternalList);
                    currentY = _drawPdfScratchpadNotes(doc, currentY);
                    currentY = _drawPdfProfitMetrics(doc, currentY, baseEstimate, calculationResults); // Pass calculationResults for final profit figures
                    _addFootersToAllPages(doc, 'Internal Estimate');

                    // --- Save ---
                    const filename = generatePdfFilename(docType);
                    doc.save(filename);
                    showFeedback(feedbackEl, `Internal PDF saved as ${filename}!`, 'green');
                } catch (error) {
                    // --- Error Handling ---
                    console.error("Error generating Internal PDF:", error);
                    const errorMsg = error instanceof Error ? error.message : String(error);
                    showFeedback(feedbackEl, `Error generating PDF: ${errorMsg}`, 'red');
                    alert(`Error generating Internal PDF:\n${errorMsg}`);
                }
            }, 100);
        }

        function generateProposalPDF() {
            const doc = getJsPDF(); if (!doc) return;
            const feedbackEl = proposalPdfFeedback;
            showFeedback(feedbackEl, "Generating...", 'orange', 0);

            // --- Data Calculation ---
            const baseEstimate = calculateBaseEstimate();
            const calculationResults = calculateOptionsAndFinalTotal(baseEstimate); // Get comprehensive calculation results
            const selectedOptionals = getSelectedOptionalAdditionsData(); // This function already filters by showOnQuote
            const scopeOfWork = scopeOfWorkInput?.value.trim() ?? '';

            // --- Validation ---
            clearValidationErrors(dashboardSection); // Clear previous errors
            if (!scopeOfWork) {
                if (scopeOfWorkInput) scopeOfWorkInput.classList.add(INVALID_CLASS);
                if (scopeOfWorkValidationError) {
                    scopeOfWorkValidationError.textContent = "Scope of Work cannot be empty for proposal.";
                    scopeOfWorkValidationError.style.display = 'inline';
                }
                showFeedback(feedbackEl, "Scope of Work required for Proposal.", 'red', 5000);
                if (scopeOfWorkInput) scopeOfWorkInput.focus();
                return; // Stop generation
            }

            // Use setTimeout for UI feedback
            setTimeout(() => {
                try {
                    let currentY = 15;
                    const docType = 'Proposal'; // Define docType for helpers

                    // --- PDF Drawing ---
                    currentY = _drawPdfHeader(doc, currentY, true, true, 1);
                    currentY = _drawPdfProposalClientInfo(doc, currentY);
                    currentY = _drawPdfScopeOfWork(doc, currentY, docType);
                    // Draw selected & shown ADJUSTMENTS using the list from calculationResults
                    currentY = _drawPdfOptions(doc, currentY, calculationResults.appliedOptionsList, docType); // Use calculationResults.appliedOptionsList
                    // Draw the main total
                    currentY = _drawPdfPriceProposal(doc, currentY, calculationResults.grandTotal); // Use calculationResults.grandTotal
                    // Draw selected & shown OPTIONAL ADDITIONS using the filtered list from selectedOptionals
                    currentY = _drawPdfOptionalAdditions(doc, currentY, selectedOptionals, docType); // selectedOptionals is already filtered by showOnQuote
                    // Draw Notes/Terms in the main body flow
                    currentY = _drawPdfNotesAndTerms(doc, currentY, docType);
                    // Add Signature Lines (before the final footer)
                    currentY = _drawPdfSignatureLines(doc, currentY, docType);

                    _addFootersToAllPages(doc, docType);

                    // --- Save ---
                    const filename = generatePdfFilename(docType);
                    doc.save(filename);
                    showFeedback(feedbackEl, `Proposal PDF saved as ${filename}!`, 'green');
                } catch (error) {
                    // --- Error Handling ---
                    console.error("Error generating Proposal PDF:", error);
                    const errorMsg = error instanceof Error ? error.message : String(error);
                    showFeedback(feedbackEl, `Error generating PDF: ${errorMsg}`, 'red');
                    alert(`Error generating Proposal PDF:\n${errorMsg}`);
                }
            }, 100);
        }

        function generateLetterheadPDF() {
            const doc = getJsPDF(); if (!doc) return;
            const feedbackEl = letterheadPdfFeedback;
            showFeedback(feedbackEl, "Generating...", 'orange', 0);

            setTimeout(() => {
                try {
                    let currentY = 15;
                    const docType = 'Letterhead'; // Define docType

                    // --- PDF Drawing ---
                    // Draw Header ONLY (no date)
                    currentY = _drawPdfHeader(doc, currentY, true, false, 1); // Page 1
                    // Draw Notes/Terms in the body
                    currentY = _drawPdfNotesAndTerms(doc, currentY, docType);
                    // Draw Footer (page number only)
                    _drawPdfFooter(doc, 1, ''); // Page 1 of 1, no prefix

                    // --- Save ---
                    const filename = generatePdfFilename(docType);
                    doc.save(filename);
                    showFeedback(feedbackEl, `Letterhead PDF saved as ${filename}!`, 'green');
                } catch (error) {
                    console.error("Error generating Letterhead PDF:", error);
                    const errorMsg = error instanceof Error ? error.message : String(error);
                    showFeedback(feedbackEl, `Error generating PDF: ${errorMsg}`, 'red');
                    alert(`Error generating Letterhead PDF:\n${errorMsg}`);
                }
            }, 100);
        }

        function generateFieldQuotePDF() {
            const doc = getJsPDF(); if (!doc) return;
            const feedbackEl = fieldQuotePdfFeedback;
            showFeedback(feedbackEl, "Generating...", 'orange', 0);

            // --- Data Calculation ---
            const baseEstimate = calculateBaseEstimate();
            const calculationResults = calculateOptionsAndFinalTotal(baseEstimate); // Get comprehensive calculation results
            const selectedOptionals = getSelectedOptionalAdditionsData(); // This function already filters by showOnQuote
            const scopeOfWork = scopeOfWorkInput?.value.trim() ?? '';

            // --- Validation ---
            clearValidationErrors(dashboardSection);
            if (!scopeOfWork) {
                if (scopeOfWorkInput) scopeOfWorkInput.classList.add(INVALID_CLASS);
                if (scopeOfWorkValidationError) {
                    scopeOfWorkValidationError.textContent = "Scope of Work cannot be empty for Field Quote.";
                    scopeOfWorkValidationError.style.display = 'inline';
                }
                showFeedback(feedbackEl, "Scope of Work required for Field Quote.", 'red', 5000);
                if (scopeOfWorkInput) scopeOfWorkInput.focus();
                return;
            }

            setTimeout(() => {
                try {
                    // Estimate vertical space needed for header (adjust as needed)
                    const headerHeightEstimate = 60; // Approx Y units for logo, company info, etc.
                    let currentY = headerHeightEstimate; // Start content below estimated header area
                    const docType = 'FieldQuote'; // Define docType

                    // --- PDF Drawing (Content Only) ---
                    // Add Date manually since header isn't drawn
                    const generationDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                    doc.setFontSize(10);
                    doc.text(`Date: ${generationDate}`, doc.internal.pageSize.getWidth() - 14, currentY - 10, {
                        align: 'right'
                    }); // Position near top-right of content area

                    currentY = _drawPdfProposalClientInfo(doc, currentY);
                    currentY = _drawPdfScopeOfWork(doc, currentY, docType);
                    currentY = _drawPdfOptions(doc, currentY, calculationResults.appliedOptionsList, docType); // Use calculationResults.appliedOptionsList
                    currentY = _drawPdfPriceProposal(doc, currentY, calculationResults.grandTotal); // Use calculationResults.grandTotal
                    currentY = _drawPdfOptionalAdditions(doc, currentY, selectedOptionals, docType); // selectedOptionals is already filtered by showOnQuote

                    // NO Footer or Signature Lines for Field Quote

                    // --- Save ---
                    const filename = generatePdfFilename(docType);
                    doc.save(filename);
                    showFeedback(feedbackEl, `Field Quote PDF saved as ${filename}!`, 'green');
                } catch (error) {
                    console.error("Error generating Field Quote PDF:", error);
                    const errorMsg = error instanceof Error ? error.message : String(error);
                    showFeedback(feedbackEl, `Error generating PDF: ${errorMsg}`, 'red');
                    alert(`Error generating Field Quote PDF:\n${errorMsg}`);
                }
            }, 100);
        }

        function generateSubcontractorPDF() {
            const doc = getJsPDF(); if (!doc) return;
            const feedbackEl = subcontractorPdfFeedback;
            showFeedback(feedbackEl, "Generating...", 'orange', 0);

            // --- Data Calculation ---
            const scopeOfWork = scopeOfWorkInput?.value.trim() ?? '';

            // Gather line items with quantities > 0
            const estimateItems = [];
            const currentJobArea = parseFloat(jobAreaInput?.value) || 0;
            const currentJobThickness = parseFloat(jobThicknessInput?.value) || 0;

            // Add PERMANENT items
            const quantityInputs = dashboardItemsDiv ? dashboardItemsDiv.querySelectorAll('.dashboard-quantity') : [];
            quantityInputs.forEach(input => {
                const quantity = parseFloat(input.value) || 0;
                if (quantity > 0) {
                    const itemIndex = parseInt(input.getAttribute('data-item-index'), 10);
                    if (!isNaN(itemIndex) && Array.isArray(currentItems) && itemIndex >= 0 && itemIndex < currentItems.length) {
                        const item = currentItems[itemIndex]; // This is the definition from currentItems
                        let itemCostForDisplay = 0; // Initialize for safety

                        if (item.pricingType === 'Fixed') {
                            itemCostForDisplay = parseFloat(item?.cost) || 0;
                        }
                        // For 'Formula' items, itemCostForDisplay remains 0 (or 'N/A')
                        // The actual total for formula items will be calculated in _drawPdfItemsTableSubcontractor

                        estimateItems.push({
                            name: String(item?.name || ''),
                            description: String(item?.description || ''),
                            unit: String(item?.unit || ''),
                            quantity: quantity,
                            cost: itemCostForDisplay, // <--- IMPORTANT: NOW INCLUDING COST FOR PERMANENT FIXED ITEMS
                            pricingType: item.pricingType
                        });
                    }
                }
            });

            // Add TEMPORARY items
            const tempItemContainers = dashboardTempItemsDiv ? dashboardTempItemsDiv.querySelectorAll('.dashboard-item-container[data-temp-item-id]') : [];
            tempItemContainers.forEach(container => {
                const quantityInput = container.querySelector('.temp-item-quantity');
                const costInput = container.querySelector('.temp-item-cost');
                const nameInput = container.querySelector('.temp-item-name');
                const descInput = container.querySelector('.temp-item-description');

                const quantity = parseFloat(quantityInput?.value) || 0;
                const cost = parseFloat(costInput?.value) || 0;
                const name = nameInput?.value.trim() || 'Unnamed Temporary Item';
                const description = descInput?.value.trim() || '';

                if (quantity > 0) {
                    estimateItems.push({
                        name: name,
                        description: description,
                        unit: 'each',
                        quantity: quantity,
                        cost: cost, // Already correctly passed for temp items
                        pricingType: 'Fixed'
                    });
                }
            });


            // --- Validation ---
            clearValidationErrors(dashboardSection);
            if (!scopeOfWork) {
                if (scopeOfWorkInput) scopeOfWorkInput.classList.add(INVALID_CLASS);
                if (scopeOfWorkValidationError) { scopeOfWorkValidationError.textContent = "Scope of Work cannot be empty for Subcontractor PDF."; scopeOfWorkValidationError.style.display = 'inline'; }
                showFeedback(feedbackEl, "Scope of Work required for Subcontractor PDF.", 'red', 5000);
                if (scopeOfWorkInput) scopeOfWorkInput.focus();
                return;
            }
            if (estimateItems.length === 0) {
                showFeedback(feedbackEl, "No items with quantities entered to show.", 'orange', 5000);
                return;
            }

            setTimeout(() => {
                try {
                    let currentY = 15;
                    const docType = 'Subcontractor';

                    // --- PDF Drawing ---
                    currentY = _drawPdfHeader(doc, currentY, true, false, 1);
                    doc.setFontSize(10); doc.setFont(undefined, 'bold'); doc.text(`SUBCONTRACTOR WORK ORDER`, 14, currentY); doc.setFont(undefined, 'normal'); currentY += 10;
                    currentY = _drawPdfJobInfo(doc, currentY, docType);
                    currentY = _drawPdfScopeOfWork(doc, currentY, docType);
                    currentY = _drawPdfItemsTableSubcontractor(doc, currentY, estimateItems);
                    currentY = _drawPdfSignatureLines(doc, currentY, docType);

                    _addFootersToAllPages(doc, 'Subcontractor Details');

                    // --- Save ---
                    const filename = generatePdfFilename(docType);
                    doc.save(filename);
                    showFeedback(feedbackEl, `Subcontractor PDF saved as ${filename}!`, 'green');
                } catch (error) {
                    console.error("Error generating Subcontractor PDF:", error);
                    const errorMsg = error instanceof Error ? error.message : String(error);
                    showFeedback(feedbackEl, `Error generating PDF: ${errorMsg}`, 'red');
                    alert(`Error generating Subcontractor PDF:\n${errorMsg}`);
                }
            }, 100);
        }
        // === JS_PDF_GENERATION END ===

        // === JS_EVENT_LISTENERS START ===
        function setupEventListeners() {
            console.log("Setting up event listeners...");
            try {
                // Navigation Buttons - Added logging here
                btnDashboard?.addEventListener('click', () => {
                    console.log("[Nav Click] Dashboard button clicked. Client Name value NOW:", clientNameInput?.value);
                    showSection('dashboard-section');
                });
                btnCostItems?.addEventListener('click', () => {
                    console.log("[Nav Click] Cost Items button clicked. Client Name value NOW:", clientNameInput?.value); // <<<< DEBUG LOG
                    showSection('cost-items-section');
                });
                btnPdfSettings?.addEventListener('click', () => {
                    console.log("[Nav Click] PDF Settings button clicked. Client Name value NOW:", clientNameInput?.value); // <<<< DEBUG LOG
                    showSection('pdf-settings-section');
                });
                btnProposalOptions?.addEventListener('click', () => {
                    console.log("[Nav Click] Proposal Options button clicked. Client Name value NOW:", clientNameInput?.value); // <<华DEBUG LOG
                    showSection('proposal-options-section');
                });
                btnScopeTemplates?.addEventListener('click', () => {
                    console.log("[Nav Click] Scope Templates button clicked. Client Name value NOW:", clientNameInput?.value); // <<<< DEBUG LOG
                    showSection('scope-templates-section');
                });

                // NEW Profile Management Event Listeners
                btnCreateProfile?.addEventListener('click', handleCreateProfile);
                btnRenameProfile?.addEventListener('click', handleRenameProfile);
                btnDeleteProfile?.addEventListener('click', handleDeleteProfile);
                profileSelectDropdown?.addEventListener('change', handleProfileSelectChange);

                // Settings Pages Save/Add Buttons
                btnSaveCostItems?.addEventListener('click', saveCostItemsAndMarkup);
                btnAddItem?.addEventListener('click', addItem);
                btnSavePdfSettings?.addEventListener('click', savePdfSettings);
                pdfLogoFileInput?.addEventListener('change', handleLogoFileSelect); // Logo selection triggers handler
                btnSaveOptions?.addEventListener('click', saveProposalOptions);
                btnAddOption?.addEventListener('click', addProposalOption);
                btnSaveScopeTemplates?.addEventListener('click', saveScopeTemplates);
                btnAddScopeTemplate?.addEventListener('click', addScopeTemplate);

                // Dashboard Actions
                btnClearQuantities?.addEventListener('click', clearQuantities);
                btnClearJobInfo?.addEventListener('click', clearJobInfo);
                btnAddTempItem?.addEventListener('click', () => addTempItemToDashboard()); // NEW: Add temporary item
                btnAddTempOption?.addEventListener('click', () => addTempOptionToDashboard()); // NEW: Add temporary option
                // PDF Generation Buttons
                btnGenerateInternalPDF?.addEventListener('click', generateInternalPDF);
                btnGenerateProposalPDF?.addEventListener('click', generateProposalPDF);
                btnGenerateLetterheadPDF?.addEventListener('click', generateLetterheadPDF); // New
                btnGenerateFieldQuotePDF?.addEventListener('click', generateFieldQuotePDF); // New
                btnGenerateSubcontractorPDF?.addEventListener('click', generateSubcontractorPDF); // New


                // Live Update Listeners (using event delegation where appropriate)
                // For Cost Item Quantities
                dashboardItemsDiv?.addEventListener('input', (event) => {
                    if (event.target.classList.contains('dashboard-quantity')) {
                        const inputElement = event.target;
                        const itemIndex = parseInt(inputElement.getAttribute('data-item-index'), 10);
                        if (!isNaN(itemIndex)) {
                            updateLineItemCost(itemIndex, inputElement); // Update specific line cost display
                        }
                        updateRunningTotals(); // Update overall totals display
                        saveDashboardStateToSession(); // Save state on input for permanent items
                    }
                });

                // For Proposal Options/Adjustments (Value Input)
                dashboardOptionsDiv?.addEventListener('input', (event) => {
                    if (event.target.classList.contains('option-dashboard-value')) {
                        updateRunningTotals(); // Recalculate totals when value changes
                        saveDashboardStateToSession(); // Save state on input for options
                    }
                });
                // For Proposal Options/Adjustments (Checkboxes)
                dashboardOptionsDiv?.addEventListener('change', (event) => {
                    if (event.target.classList.contains('option-toggle-checkbox') ||
                        event.target.classList.contains('option-dashboard-is-optional') ||
                        event.target.classList.contains('option-dashboard-show-toggle')) {
                        updateRunningTotals(); // Recalculate totals when any relevant checkbox changes state
                        saveDashboardStateToSession(); // Save state on change for options checkboxes
                    }
                });

                // Markup Input Listener (Settings Page)
                markupInput?.addEventListener('input', () => {
                    setSaveButtonState(btnSaveCostItems, true); // Mark settings as unsaved
                    // Update dashboard totals *if* dashboard is active (otherwise wait for save)
                    if (dashboardSection?.classList.contains('active')) {
                        updateRunningTotals();
                    }
                });

                // Dimension Input Listeners (Dashboard)
                [jobAreaInput, jobThicknessInput].forEach(input => {
                    input?.addEventListener('input', () => {
                        updateConcreteCalculatorDisplay(); // Update helper calc display
                        // Update all line item costs if formulas depend on these dimensions
                        if (dashboardItemsDiv) {
                            dashboardItemsDiv.querySelectorAll('.dashboard-quantity').forEach(qtyInput => {
                                const idx = parseInt(qtyInput.getAttribute('data-item-index'), 10);
                                if (!isNaN(idx)) { updateLineItemCost(idx, qtyInput); } // Re-run line cost calc
                            });
                        }
                        updateRunningTotals(); // Recalculate all totals
                        saveDashboardStateToSession(); // Save state on dimension change
                    });
                });

                // Client Name and Project Info Input Listeners (Dashboard)
                [clientNameInput, projectInfoInput, dashboardScratchpad].forEach(input => {
                    input?.addEventListener('input', () => {
                        saveDashboardStateToSession(); // Save state on general info input
                    });
                });

                // Scope Template Selector / Manual Scope Input (Dashboard)
                scopeTemplateSelect?.addEventListener('change', (event) => {
                    if (scopeOfWorkInput) {
                        const selectedId = event.target.value;
                        // Find template text or clear if default option selected
                        scopeOfWorkInput.value = selectedId ? (currentScopeTemplates.find(t => t.id === selectedId)?.text || '') : '';
                        // Clear validation error when selecting a template
                        scopeOfWorkInput.classList.remove(INVALID_CLASS);
                        if (scopeOfWorkValidationError) { scopeOfWorkValidationError.textContent = ''; scopeOfWorkValidationError.style.display = 'none'; }
                        saveDashboardStateToSession(); // Save state after scope change
                    }
                });
                scopeOfWorkInput?.addEventListener('input', () => {
                    // Clear validation error on typing
                    if (scopeOfWorkInput.value.trim()) {
                        scopeOfWorkInput.classList.remove(INVALID_CLASS);
                        if (scopeOfWorkValidationError) { scopeOfWorkValidationError.textContent = ''; scopeOfWorkValidationError.style.display = 'none'; }
                    }
                    // Deselect template dropdown if user starts typing custom scope
                    if (scopeTemplateSelect?.value) { scopeTemplateSelect.value = ""; }
                    saveDashboardStateToSession(); // Save state on scope input
                });

                // Backup / Restore Button Listeners
                [btnExportSettings, btnExportSettingsPdf, btnExportSettingsOptions, btnExportSettingsScopes].forEach(btn => btn?.addEventListener('click', exportSettings));
                [btnImportSettings, btnImportSettingsPdf, btnImportSettingsOptions, btnImportSettingsScopes].forEach(btn => btn?.addEventListener('click', triggerImport));
                importFileInput?.addEventListener('change', importSettings); // Listener for the hidden file input

                // Unsaved Changes Indicator Listeners (for Settings pages)
                pageSections.forEach(section => {
                    const saveButton = section.querySelector('.save-button');
                    if (saveButton && !section.id.startsWith('dashboard')) {
                        section.addEventListener('input', (event) => {
                            const target = event.target;
                            if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
                                setSaveButtonState(saveButton, true);
                                if (currentProfileName) isProfileDirty = true;
                            }
                        });
                        section.addEventListener('change', (event) => {
                            const target = event.target;
                            if (target.tagName === 'SELECT' || (target.tagName === 'INPUT' && target.type === 'checkbox')) {
                                setSaveButtonState(saveButton, true);
                                if (currentProfileName) isProfileDirty = true;
                            }
                        });
                    }
                });

                console.log("Event listeners set up successfully.");

            } catch (e) {
                console.error("Error setting up event listeners:", e);
                const errorMsg = `A critical error occurred setting up page interactions: ${e.message}. Some features may not work. Check console (F12).`;
                alert(errorMsg);
                if (initializationErrorDisplay) {
                    initializationErrorDisplay.textContent = errorMsg;
                    initializationErrorDisplay.style.display = 'block';
                }
            }
        }
        // === JS_EVENT_LISTENERS END ===

        // === JS_INIT START ===
        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded. Initializing Estimator with Profile System...");
            try {
                // Check LocalStorage availability
                try {
                    localStorage.setItem('__testLocalStorageAvailability', 'test');
                    localStorage.removeItem('__testLocalStorageAvailability');
                    console.log("LocalStorage check passed.");
                } catch (lsError) {
                    throw new Error(`LocalStorage is not available or writeable. Settings cannot be saved. Error: ${lsError.message}`);
                }

                // 1. Load the list of all profile names
                profileNamesList = getProfileNamesFromStorage();
                console.log("Available profiles:", profileNamesList);

                // 2. Determine the active profile to load
                let lastActiveProfile = getActiveProfileNameFromStorage();
                if (lastActiveProfile && profileNamesList.includes(lastActiveProfile)) {
                    currentProfileName = lastActiveProfile;
                } else if (profileNamesList.length > 0) {
                    currentProfileName = profileNamesList[0]; // Default to the first profile in the list
                } else {
                    currentProfileName = null; // No profiles exist yet
                }
                console.log("Target profile to load on init:", currentProfileName);

                // 3. Populate the profile select dropdown (BEFORE loading settings, so it's ready)
                populateProfileSelectDropdown(); // This will also set currentProfileName if it was null but profiles exist

                // 4. Load settings for the determined active profile (or defaults if none)
                // loadAllSettings will internally set currentProfileName and save it as active
                loadAllSettings(currentProfileName); // Pass the determined name

                // 5. Set up all interactive elements and event listeners
                setupEventListeners();

                // 6. Show the initial section (Dashboard)
                showSection('dashboard-section');

                // 7. Set initial dirty flag (profile just loaded or defaults applied)
                // If currentProfileName is null (meaning app defaults loaded, no profile selected),
                // then it IS dirty because these defaults aren't saved to any profile.
                // If a profile was loaded, loadAllSettings sets isProfileDirty to false.
                if (!currentProfileName && profileNamesList.length === 0) {
                    isProfileDirty = true; // Indicate that initial default set needs saving to a new profile
                }


                console.log("Estimator Initialized Successfully with Profile System.");

            } catch (e) {
                console.error("Error during initialization:", e);
                const errorMsg = `Initialization Error: ${e.message}. The application might not function correctly. Check console (F12) for details.`;
                alert(errorMsg);
                if (initializationErrorDisplay) {
                    initializationErrorDisplay.textContent = errorMsg;
                    initializationErrorDisplay.style.display = 'block';
                }
            }
        });

        // === JS_INIT END ===
    </script>
</body>

</html>